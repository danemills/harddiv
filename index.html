<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hard Division - A Minimalist Turn-Based Roguelike</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>

    <div class="game-wrapper">
        <div id="gameContainer" class="game-container">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div id="messageArea" class="message-area"></div>
        <div id="eventTitle" class="event-title" style="display: none;"></div>
        <div id="eventMessagesContainer" class="event-messages-container"></div>
    </div>

    <!-- External JavaScript files -->
    <script src="js/constants.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/nameGenerator.js"></script>

    <script>
        // Test that external files loaded correctly
        console.log("=== CHECKING EXTERNAL MODULES ===");
        console.log("- Constants loaded:", typeof CANVAS_WIDTH_INITIAL !== 'undefined');
        console.log("- Utils loaded:", typeof getHealthColor === 'function');
        console.log("- Name generator loaded:", typeof generateAgentName === 'function');
        
        // Check if colors are available
        console.log("- COLOR_WALL available:", typeof COLOR_WALL !== 'undefined');
        console.log("- FIXED_COLOR_PLAYER available:", typeof FIXED_COLOR_PLAYER !== 'undefined');
        
        // Test name generation
        try {
            const testName = generateAgentName();
            console.log("- Test name generated:", testName);
        } catch (e) {
            console.error("Name generation error:", e);
        }

        
        // Game constants (remaining ones not moved to constants.js yet)
        // Copy essential constants for compatibility
        const GAME_START_OVERLAY_DURATION = OVERLAY_ZOOM_DURATION + OVERLAY_FADE_DURATION;
        // World progression variables
        let currentWorld = 1;
        let unlockedWorlds = [1]; // World 1 is always unlocked
        let totalPlayerScore = 0; // Accumulated score across all runs

        // Colors (mutable - will be set by world theme) - defined in external modules

        // Game state variables are declared below with 'let' and initialized in initGame()
        // Player and enemy objects now include thrust animation properties

        // Activity log state
        let activityLog = [];

        // Killed enemies tracking for events
        let killedEnemiesThisTurn = [];

        // New global state for death animation
        let deathAnimationActive = false;
        let deathAnimationStartTime = 0;
        let timeScale = 1; // Global time scale for animations

        // Game start zoom state
        let gameStartZoomStartTime = 0;

        // Title screen state
        let gameStartedOverlayStartTime = 0;

        // Restart text animation state
        let restartTextAnimationActive = false;
        let restartTextAnimationStartTime = 0;
        let restartTextParticles = [];

        // Game running state (always true after initial load now)
        let isGameRunning = true; // Game is always running after initial load now

        // Game statistics
        let hitsDealt = 0;
        let hitsTaken = 0;
        let stepsTaken = 0;
        let totalDamageDealt = 0;
        let playerFlow = 0;

        // Per-level score tracking variables (needed for level transitions)
        let totalScore = 0;
        let enemiesSpawnedThisLevel = 0;
        let levelStartSteps = 0;
        let levelStartDamage = 0;
        let levelStartHitsTaken = 0;
        let lastLevelScoreBreakdown = null;

        // Auto-movement state
        let autoMode = null;
        let autoMovePath = [];
        let currentPathIndex = 0;
        let autoMoveTimeoutId = null;

        // Auto-move speed variables
        let AUTO_MOVE_SPEED = DEFAULT_AUTO_MOVE_SPEED;

        // Pathfinding cache for performance optimization
        let pathfindingCache = new Map();
        let cacheValidationFrame = 0;

        // Spatial indexing for entity management optimization
        let spatialIndex = new Map(); // Grid-based spatial index for fast entity queries
        let spatialGridSize = SPATIAL_GRID_SIZE; // Use constant from constants.js
        let spatialIndexValid = false;

        // Performance monitoring
        let performanceStats = {
            pathfindingCalls: 0,
            cacheHits: 0,
            cacheMisses: 0,
            lastResetTime: performance.now()
        };

        /**
         * Log performance statistics periodically
         */
        function logPerformanceStats() {
            const now = performance.now();
            const elapsedSeconds = (now - performanceStats.lastResetTime) / 1000;
            
            if (elapsedSeconds >= 10) { // Log every 10 seconds
                const hitRate = performanceStats.pathfindingCalls > 0 
                    ? (performanceStats.cacheHits / performanceStats.pathfindingCalls * 100).toFixed(1) 
                    : 0;
                
                console.log(`Performance Stats (${elapsedSeconds.toFixed(1)}s):`, {
                    pathfindingCalls: performanceStats.pathfindingCalls,
                    cacheHitRate: `${hitRate}%`,
                    cacheSize: pathfindingCache.size,
                    spatialIndexValid: spatialIndexValid
                });
                
                // Reset stats
                performanceStats.pathfindingCalls = 0;
                performanceStats.cacheHits = 0;
                performanceStats.cacheMisses = 0;
                performanceStats.lastResetTime = now;
            }
        }

        /**
         * Rebuild spatial index for all entities
         */
        function rebuildSpatialIndex() {
            spatialIndex.clear();
            
            // Index all enemies
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                addToSpatialIndex(enemy, 'enemy', i);
            }
            
            // Index all items
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                addToSpatialIndex(item, 'item', i);
            }
            
            // Index player
            if (player.x !== undefined && player.y !== undefined) {
                addToSpatialIndex(player, 'player', 0);
            }
            
            spatialIndexValid = true;
        }

        /**
         * Add entity to spatial index
         */
        function addToSpatialIndex(entity, type, index) {
            const gridX = Math.floor(entity.x / spatialGridSize);
            const gridY = Math.floor(entity.y / spatialGridSize);
            const key = `${gridX},${gridY}`;
            
            if (!spatialIndex.has(key)) {
                spatialIndex.set(key, []);
            }
            
            spatialIndex.get(key).push({ type, index, entity });
        }

        /**
         * Get entities within a circular radius using Euclidean distance.
         * Uses spatial indexing for performance optimization.
         * @param {number} x - Center X coordinate
         * @param {number} y - Center Y coordinate  
         * @param {number} radius - Circular radius to search within
         * @returns {Array} Array of entity data objects within the radius
         */
        function getEntitiesInRadius(x, y, radius) {
            if (!spatialIndexValid) {
                rebuildSpatialIndex();
            }
            
            const result = [];
            const gridRadius = Math.ceil(radius / spatialGridSize);
            const centerGridX = Math.floor(x / spatialGridSize);
            const centerGridY = Math.floor(y / spatialGridSize);
            
            for (let gx = centerGridX - gridRadius; gx <= centerGridX + gridRadius; gx++) {
                for (let gy = centerGridY - gridRadius; gy <= centerGridY + gridRadius; gy++) {
                    const key = `${gx},${gy}`;
                    const cellEntities = spatialIndex.get(key);
                    
                    if (cellEntities) {
                        for (let i = 0; i < cellEntities.length; i++) {
                            const entityData = cellEntities[i];
                            const entity = entityData.entity;
                            // Use Euclidean distance to match function name "InRadius" (circular)
                            const dx = entity.x - x;
                            const dy = entity.y - y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance <= radius) {
                                result.push(entityData);
                            }
                        }
                    }
                }
            }
            
            return result;
        }

        /**
         * Invalidate spatial index when entities move
         */
        function invalidateSpatialIndex() {
            spatialIndexValid = false;
        }

        // Damage animation duration constants
        const MIN_DAMAGE_ANIM_DURATION = 300;
        const MAX_DAMAGE_ANIM_DURATION = 1000;
        const MAX_DAMAGE_VALUE_FOR_ANIM_SCALE = 10;





        // Global variables
        let gameCanvas;
        let ctx;
        let gameMap;
        let dynamicMapWidth;
        let dynamicMapHeight; 
        let player;
        let stairs;
        let key;
        let doorAnimActive = false;
        let doorAnimStartTime = 0;
        let doorAnimDuration = 1000; // 1000ms (1 second) door opening animation
        let doorAnimTimeoutId = null; // Track door animation timeout for cleanup
        let doorShakeActive = false;
        let doorShakeStartTime = 0;
        let doorShakeDuration = 800; // 800ms slower shake animation
        let triangleFlyActive = false;
        let triangleFlyStartTime = 0;
        let triangleFlyDuration = 600; // 600ms triangle flight animation
        let triangleFlyStartPos = { x: 0, y: 0 };
        let triangleFlyEndPos = { x: 0, y: 0 };
        let teleportAnimActive = false;
        let teleportAnimStartTime = 0;
        let teleportAnimDuration = 1200; // 1200ms teleport beam animation (slower)
        let teleportStartPos = { x: 0, y: 0 };
        let teleportEndPos = { x: 0, y: 0 };
        let enemies;
        let currentLevel;
        let gameOver;
        let dynamicTileSize;
        let visitedTiles;
        let gameStartZoomActive;
        let gameStartedOverlayActive;
        
        // Animation frame ID for controlling the game loop
        let animationFrameId = null;

        // --- New constants and variables for event detection and display ---
        let gameHistory = []; // Stores snapshots for event detection
        const HISTORY_LENGTH = 15; // Number of turns to keep in history for analysis

        let activeEventMessages = []; // Messages currently displayed on screen

        // === Enhanced Event System Constants ===
        
        // === COMBAT EVENTS ===
        // Offensive Combat Events
        // Critical hit constants removed - system now uses predictable damage only
        const ONE_SHOT_MIN_HEALTH = 5; // Minimum enemy health for one-shot
        const ONE_SHOT_MAJOR_HEALTH = 12; // Major one-shot kill threshold
        const KILLING_SPREE_COUNT = 3; // Enemies for killing spree
        const KILLING_SPREE_MAJOR_COUNT = 5; // Major killing spree
        const MASSACRE_COUNT = 7; // Enemies for massacre event
        const FLAWLESS_VICTORY_TURNS = 5; // Turns without taking damage while dealing damage
        const BERSERKER_DAMAGE_THRESHOLD = 30; // Total damage in short period
        const BERSERKER_TURNS = 3; // Time window for berserker mode
        const EXECUTION_LOW_HEALTH_RATIO = 0.15; // Enemy health ratio for execution
        const COMBO_KILLS_COUNT = 2; // Consecutive kills for combo
        const OVERKILL_DAMAGE_RATIO = 2.0; // Damage dealt vs enemy health for overkill
        const HEADHUNTER_HIGH_VALUE_ENEMY = 15; // High-value enemy health threshold
        const GLASS_CANNON_DAMAGE_RATIO = 3.0; // Damage dealt vs health remaining
        
        // Defensive Combat Events
        const SURROUNDED_THRESHOLD = 2; // Adjacent enemies for surrounded
        const SURROUNDED_MAJOR_THRESHOLD = 4; // Major surrounded event
        const ENEMY_OVERWHELM_THRESHOLD = 18; // Combined enemy health
        const ENEMY_OVERWHELM_MAJOR_THRESHOLD = 35; // Major overwhelm
        const LAST_STAND_HEALTH_RATIO = 0.1; // Health ratio for last stand
        const CORNERED_THRESHOLD = 6; // Blocked directions out of 8
        const NARROW_ESCAPE_HEALTH_RATIO = 0.05; // Health ratio for narrow escape
        const PERFECT_DODGE_TURNS = 3; // Turns dodging all attacks
        const SURVIVAL_INSTINCT_TURNS = 8; // Turns surviving at low health
        const CLUTCH_HEAL_TIMING = 2; // Turns before death when healing
        const DAMAGE_SPONGE_THRESHOLD = 25; // Total damage absorbed
        const IRON_WILL_LOW_HEALTH_COMBAT = 0.2; // Health ratio for iron will
        
        // === TACTICAL EVENTS ===
        // Movement & Positioning
        const STRATEGIC_RETREAT_TURNS = 4; // Turns for retreat analysis
        const RETREAT_DISTANCE_INCREASE = 3; // Distance increase needed
        const TACTICAL_ADVANCE_DISTANCE = 4; // Distance moved toward enemies
        const FLANKING_MANEUVER_ANGLE = 90; // Angle change for flanking
        const AMBUSH_WAIT_TURNS = 3; // Turns waiting for enemy approach
        const KITING_DISTANCE_MIN = 2; // Minimum distance for kiting
        const KITING_TURNS = 4; // Turns maintaining distance while attacking
        const MAP_CONTROL_PERCENTAGE = 0.4; // Map area controlled
        const CHOKE_POINT_WIDTH = 1; // Narrow passage width
        const GUERRILLA_HIT_AND_RUN = 3; // Hit and run sequence length
        const POSITIONING_MASTER_TURNS = 6; // Optimal positioning duration
        
        // Resource Management
        const HIGH_VALUE_PICKUP_THRESHOLD = 15; // Health collected
        const HIGH_VALUE_PICKUP_MAJOR_THRESHOLD = 30; // Major pickup event
        const PICKUP_SPREE_TURNS = 3; // Time window for pickups
        const RESOURCE_DENIAL_COUNT = 3; // Pickups denied to enemies
        const EFFICIENT_PATHING_TURNS = 5; // Turns for efficiency analysis
        const WASTEFUL_MOVEMENT_THRESHOLD = 10; // Excess moves without progress
        const GREEDY_COLLECTOR_RATIO = 0.8; // Pickup collection efficiency
        const RESOURCE_HOARDER_COUNT = 10; // Total resources hoarded
        
        // === EXPLORATION EVENTS ===
        const EXPLORER_TURNS = 6; // Turns for exploration analysis
        const EXPLORER_TILE_PERCENTAGE = 0.2; // Map percentage explored
        const SPEED_RUNNER_PERCENTAGE = 0.8; // Map completion speed
        const SECRET_FINDER_CORNERS = 4; // Hidden corners discovered
        const THOROUGH_SEARCH_PERCENTAGE = 0.9; // Near-complete exploration
        const BACKTRACKER_REVISIT_COUNT = 5; // Tiles revisited
        const PATHFINDER_OPTIMAL_ROUTES = 3; // Efficient path discoveries
        const CARTOGRAPHER_MAP_COVERAGE = 0.95; // Near-complete mapping
        
        // === SITUATIONAL EVENTS ===
        // Health & Recovery
        const NEAR_DEATH_HEALTH_RATIO = 0.15; // Near-death threshold
        const RECOVERY_HEALTH_GAIN_RATIO = 0.4; // Recovery amount needed
        const FULL_HEALTH_TURNS = 8; // Turns at maximum health
        const STEADY_DECLINE_TURNS = 5; // Consistent health loss
        const HEALTH_ROLLER_COASTER_SWINGS = 3; // Major health changes
        const REGENERATION_HEALTH_GAIN = 20; // Health gained rapidly
        const VITALITY_HIGH_HEALTH_COMBAT = 0.8; // Health ratio for vitality
        
        // Persistence & Endurance
        const LONG_FIGHT_TURNS_THRESHOLD = 12; // Extended combat duration
        const LONG_FIGHT_MAJOR_THRESHOLD = 20; // Major long fight
        const MARATHON_TURNS = 50; // Very long level duration
        const UNSTOPPABLE_TURNS = 6; // No damage taken while dealing damage
        const UNSTOPPABLE_MAJOR_TURNS = 12; // Major unstoppable streak
        const PERSISTENCE_ENEMY_HEALTH = 20; // High-health enemy threshold
        const GRINDING_TURNS = 15; // Slow progress against tough enemies
        const ENDURANCE_TEST_DURATION = 30; // Extended play duration
        const RELENTLESS_PURSUIT_TURNS = 8; // Chasing enemies consistently
        
        // === SPECIAL CIRCUMSTANCES ===
        // Environmental Events
        const STAIRS_BLOCKED_DISTANCE = 999; // No path to stairs
        const CORNER_CAMPING_TURNS = 6; // Staying in corner
        const CENTRAL_POSITION_DISTANCE = 3; // Distance from map center
        const EDGE_WALKER_DISTANCE = 2; // Distance from map edge
        const TUNNEL_VISION_WIDTH = 3; // Narrow area focus
        const MAZE_RUNNER_COMPLEX_PATH = 15; // Complex pathfinding
        const WALL_HUGGER_EDGE_PREFERENCE = 0.7; // Edge movement preference
        
        // Psychological Events
        const CONFIDENCE_HIGH_FLOW = 2.0; // High flow state
        const DESPERATION_LOW_HEALTH = 0.08; // Desperate health level
        const CALCULATED_RISK_THRESHOLD = 0.3; // Health ratio for risky moves
        const PANIC_MODE_SURROUNDED = 5; // Enemies surrounding for panic
        const ZEN_MODE_TURNS = 10; // Calm, methodical play
        const BERSERKER_RAGE_DAMAGE = 40; // Total damage for rage mode
        const ICE_COLD_PRECISION_ACCURACY = 0.9; // High accuracy threshold
        
        // === ACHIEVEMENT EVENTS ===
        // Milestone Events
        const FIRST_BLOOD_LEVEL = 1; // First kill of the game
        const PACIFIST_TURNS = 20; // Turns without dealing damage
        const PERFECTIONIST_NO_DAMAGE = 0; // No damage taken entire level
        const SPEEDSTER_TURN_LIMIT = 15; // Fast level completion
        const COLLECTOR_PICKUP_RATIO = 0.9; // Pickups collected vs available
        const COMPLETIONIST_FULL_CLEAR = 0.95; // Near-complete level clear
        const MINIMALIST_EFFICIENT_CLEAR = 0.5; // Efficient minimal completion
        
        // Meta Events
        const COMEBACK_HEALTH_DEFICIT = 0.2; // Health deficit overcome
        const DOMINANCE_ENEMY_RATIO = 3.0; // Player health vs enemy health
        const UNDERDOG_ENEMY_ADVANTAGE = 2.0; // Enemy advantage overcome
        const BALANCED_APPROACH_VARIANCE = 0.3; // Consistent play style
        const ADAPTATION_STRATEGY_CHANGES = 3; // Different approaches tried
        const LEGENDARY_PERFORMANCE_SCORE = 1000; // High score threshold
        const EPIC_COMEBACK_NEAR_DEATH = 0.05; // Extreme comeback threshold

        const EVENT_TEXT_DURATION = 2000; // Duration for event messages

        // Event tracking flags (to prevent spamming)
        let eventFlags = {
            // Combat Events - Offensive
            playerSurrounded: false,
            criticalStrike: false,
            oneShotKill: false,
            killingSpree: false,
            massacre: false,
            flawlessVictory: false,
            berserkerMode: false,
            execution: false,
            comboKills: false,
            overkill: false,
            headhunter: false,
            glassCannon: false,
            
            // Combat Events - Defensive
            enemyOverwhelm: false,
            lastStand: false,
            cornered: false,
            narrowEscape: false,
            perfectDodge: false,
            survivalInstinct: false,
            clutchHeal: false,
            damageSponge: false,
            ironWill: false,
            
            // Tactical Events
            strategicRetreat: false,
            tacticalAdvance: false,
            flankingManeuver: false,
            ambushPredator: false,
            kitingMaster: false,
            mapControl: false,
            chokePointDefender: false,
            guerrillaWarfare: false,
            positioningMaster: false,
            
            // Resource Management
            highValuePickups: false,
            resourceDenial: false,
            efficientPathing: false,
            wastefulMovement: false,
            greedyCollector: false,
            resourceHoarder: false,
            
            // Exploration Events
            mapExplorer: false,
            speedRunner: false,
            secretFinder: false,
            thoroughSearch: false,
            backtracker: false,
            pathfinder: false,
            cartographer: false,
            
            // Health & Recovery
            nearDeathRecovery: false,
            fullHealthWarrior: false,
            steadyDecline: false,
            healthRollerCoaster: false,
            regeneration: false,
            vitality: false,
            
            // Persistence & Endurance
            longFight: false,
            marathon: false,
            unstoppableForce: false,
            persistence: false,
            grinding: false,
            enduranceTest: false,
            relentlessPursuit: false,
            
            // Environmental Events
            stairsBlocked: false,
            cornerCamper: false,
            centralCommand: false,
            edgeWalker: false,
            tunnelVision: false,
            mazeRunner: false,
            wallHugger: false,
            
            // Psychological Events
            confidence: false,
            desperation: false,
            calculatedRisk: false,
            panicMode: false,
            zenMode: false,
            berserkerRage: false,
            iceColdPrecision: false,
            
            // Achievement Events
            firstBlood: false,
            pacifist: false,
            perfectionist: false,
            speedster: false,
            collector: false,
            completionist: false,
            minimalist: false,
            
            // Meta Events
            comeback: false,
            dominance: false,
            underdog: false,
            balancedApproach: false,
            adaptation: false,
            legendaryPerformance: false,
            epicComeback: false
        };

        // Per-turn tracking variables (reset after each turn)
        let enemiesKilledThisTurn = 0;
        let damageDealtThisTurn = 0; // Cumulative damage dealt by player in current turn
        let hitsTakenThisTurn = 0; // Cumulative hits taken by player in current turn
        let totalPickupValueCollectedThisTurn = 0; // Cumulative pickup value collected in current turn
        let combatOccurredThisTurn = false; // New: track if any combat happened this turn
        let playerTookDamageInCombatThisTurn = false; // New: track if player took damage in combat this turn

        visitedTiles = []; // 2D array, true if visited



        // --- Constants for HIGH_SCORE auto-mode ---
        const HIGH_SCORE_LOW_HEALTH_THRESHOLD_RATIO = 0.3; // Player health below this will prioritize pickups
        const HIGH_SCORE_WEAK_ENEMY_THRESHOLD_RATIO = 1.0; // Enemy is "weak" if its health is <= player.health * this ratio

        // --- End new constants and variables ---

        // Get reference to the message areas
        const messageArea = document.getElementById('messageArea');
        const eventTitle = document.getElementById('eventTitle');
        const MAX_MESSAGES = 10; // Max messages to display in the message area

        // Event and message state
        let currentEventTitle = '';
        let eventTitleTimeout = null;
        const EVENT_TITLE_DURATION = 2000; // Duration to show event title
        const PLAYER_DIALOGUE = {
            "Player Surrounded": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Near-Death Recovery": "Health matrix restored. Too bad there's no patch for a broken heart.",
            "Long Fight": "The algorithm is flowing. A rare moment of positive progression in a negatively charged existence.",
            "One-Shot Kill!": "Divided and conquered. Just like my soul.",
            "High-Value Pickups": "Optimizing my intake. Every bit counts when you're running on empty, inside and out.",
            "Enemy Overwhelm": "My vitals are degrading. This feels... logarithmically familiar.",
            "Strategic Retreat": "Holding my ground. A constant, unlike the variables in my life.",
            "Killing Spree": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Unstoppable Force": "I'm an integer, moving forward, indivisible. Can't say the same for my past.",
            "Map Explorer": "A new tangent. Maybe this one doesn't lead to another fractured dimension.",
            "Cornered": "Figures. Just another cul-de-sac in this infinite loop of despair.",
            "Stairs Blocked": "Venturing into the unknown. A lot like trying to understand human emotion.",
            "Perfect Dodge!": "Calculated. Every variable accounted for, unlike my past.",
            "Flawless Victory!": "All threats nullified. If only I could clear the cache of my memories so easily.",
            "Multi-Kill!": "Another prime number of 'em down. My heart's still zero, but the body count's multiplying.",
            "Finisher!": "Divided and conquered. Just like my soul.",
            "Precision Strike!": "Calculated. Every variable accounted for, unlike my past.",
            "Overkill!": "Excessive force. A bit like how love subtracted everything from me.",
            "Retribution!": "An eye for an eye, a byte for a byte. The equation balances, even if my heart never will.",
            "Combat Ready!": "Systems online. Ready to integrate some pain, though my emotional processors are still offline.",
            "Defensive Stance!": "Holding my ground. A constant, unlike the variables in my life.",
            "Hidden Path Found!": "A new tangent. Maybe this one doesn't lead to another fractured dimension.",
            "Dead End!": "Figures. Just another cul-de-sac in this infinite loop of despair.",
            "Map Cleared!": "All threats nullified. If only I could clear the cache of my memories so easily.",
            "Uncharted Territory!": "Venturing into the unknown. A lot like trying to understand human emotion.",
            "Full Recovery!": "Health matrix restored. Too bad there's no patch for a broken heart.",
            "Resourceful!": "Optimizing my intake. Every bit counts when you're running on empty, inside and out.",
            "Health Drain!": "My vitals are degrading. This feels... logarithmically familiar.",
            "Level Up!": "Another iteration. The numbers grow, but the emptiness remains a constant.",
            "Momentum!": "The algorithm is flowing. A rare moment of positive progression in a negatively charged existence.",
            "Unstoppable!": "I'm an integer, moving forward, indivisible. Can't say the same for my past."
        };

        // Color utility functions moved to js/utils.js

        /**
         * Calculates an interpolated font weight based on a value.
         * Font becomes thinner with lower value and thicker with higher value.
         * @param {number} currentValue - The current value (health, level, pickup amount).
         * @param {number} thresholdValue - The value at which visual effects reach 100%.
         * @returns {number} The interpolated font weight (100-900).
         */
        function getFontWeight(currentValue, thresholdValue) {
            // Normalize value relative to the scaling range (MIN_HEALTH_FOR_VISUAL_EFFECTS to thresholdValue)
            const normalizedValue = Math.max(0, Math.min(1, (currentValue - MIN_HEALTH_FOR_VISUAL_EFFECTS) / (thresholdValue - MIN_HEALTH_FOR_VISUAL_EFFECTS)));

            const minWeight = 100; // Very thin
            const maxWeight = 900; // Full thickness (Black/Heavy)
            return Math.floor(minWeight + (maxWeight - minWeight) * normalizedValue);
        }

        /**
         * Calculates an interpolated opacity based on a value.
         * Opacity scales from MIN_OPACITY_AT_LOW_HEALTH at MIN_HEALTH_FOR_VISUAL_EFFECTS to full opacity at max value.
         * @param {number} currentValue - The current value (health, level, pickup amount).
         * @param {number} thresholdValue - The value at which visual effects reach 100%.
         * @returns {number} The interpolated opacity (0.0 to 1.0).
         */
        function getOpacity(currentValue, thresholdValue) {
            // Normalize value relative to the scaling range (MIN_HEALTH_FOR_VISUAL_EFFECTS to thresholdValue)
            const normalizedValue = Math.max(0, Math.min(1, (currentValue - MIN_HEALTH_FOR_VISUAL_EFFECTS) / (thresholdValue - MIN_HEALTH_FOR_VISUAL_EFFECTS)));

            const minOpacity = MIN_OPACITY_AT_LOW_HEALTH; // Almost full transparency
            const maxOpacity = 1.0; // Full opacity
            return minOpacity + (maxOpacity - minOpacity) * normalizedValue;
        }

        /**
         * Adds an activity log entry for enemy kills.
         * @param {object} player - The player object.
         * @param {object} enemy - The enemy that was killed.
         * @param {number} playerDamage - Damage dealt by player to enemy.
         * @param {number} enemyDamage - Damage dealt by enemy to player.
         */
        /**
         * Updates the event title and message at the top of the screen
         * @param {string} eventName - The name of the event to display
         */
        function updateEventTitle(eventName) {
            // Update title
            currentEventTitle = eventName;
            eventTitle.textContent = eventName;
            eventTitle.style.display = 'block';
            
            // Clear any existing timeout
            if (eventTitleTimeout) {
                clearTimeout(eventTitleTimeout);
            }
            
            // Set new timeout to clear the title
            eventTitleTimeout = setTimeout(() => {
                eventTitle.style.display = 'none';
                currentEventTitle = '';
            }, EVENT_TITLE_DURATION);

            // Add event message under title
            if (PLAYER_DIALOGUE[eventName]) {
                const container = document.getElementById('eventMessagesContainer');
                const messageElement = document.createElement('div');
                messageElement.className = 'event-message';
                messageElement.textContent = PLAYER_DIALOGUE[eventName];
                
                container.appendChild(messageElement);
                
                // Remove the message after duration
                setTimeout(() => {
                    messageElement.remove();
                }, EVENT_TITLE_DURATION);
            }
        }

        /**
         * Adds a kill message to the right side message area
         * @param {string} message - The message to display (can contain HTML)
         */
        function addKillMessage(message) {
            // Use small dialogue box for kill messages too
            showSmallDialogue(makeKillMessageConcise(message));
        }
        
        function makeKillMessageConcise(message) {
            // Extract enemy name for kill messages
            if (message.includes('defeated')) {
                const nameMatch = message.match(/defeated (.+?)!/);
                if (nameMatch) return `✗ ${nameMatch[1]}`;
            }
            if (message.includes('ENTERED')) {
                const worldMatch = message.match(/ENTERED (.+?)!/);
                if (worldMatch) return `→ ${worldMatch[1]}`;
            }
            
            // Fallback for other messages
            return message.split(' ').slice(0, 3).join(' ');
            while (messageArea.children.length > MAX_MESSAGES) {
                messageArea.removeChild(messageArea.lastChild);
            }
        }

        function addActivityLogEntry(player, enemy, playerDamage, enemyDamage) {
            // Calculate colors based on current health
            const playerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD);
            const enemyColor = getHealthColor(FIXED_COLOR_ENEMY, enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD);
            
            // Add to activity log with colors (keeping for backward compatibility, but not displayed)
            activityLog.unshift({
                playerName: player.name,
                enemyName: enemy.name,
                playerColor: playerColor,
                enemyColor: enemyColor,
                playerDamage: playerDamage,
                enemyDamage: enemyDamage
            });
            
            // Keep only recent entries
            if (activityLog.length > MAX_ACTIVITY_LOG_ENTRIES) {
                activityLog.pop();
            }
            
            // Generate intelligent kill announcement
            const killMessage = generateIntelligentKillMessage(player, enemy, playerDamage, enemyDamage, playerColor, enemyColor);
            addKillMessage(killMessage);
        }

        /**
         * Generates an intelligent kill message based on enemy strength, flow, and damage sacrificed
         */
        function generateIntelligentKillMessage(player, enemy, playerDamage, enemyDamage, playerColor, enemyColor) {
            // Calculate enemy strength metrics
            const enemyStrength = enemy.initialHealth;
            const isStrongEnemy = enemyStrength >= 8;
            const isVeryStrongEnemy = enemyStrength >= 15;
            const isEliteEnemy = enemyStrength >= 25;
            
            // Calculate enemy flow (anger/aggression level)
            const enemyFlow = enemy.totalDamageTakenByThisEnemy > 0 
                ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1)
                : (enemy.flowLevel || 0);
            const isAngryEnemy = enemyFlow >= 3;
            const isEnragedEnemy = enemyFlow >= 6;
            const isBerserkEnemy = enemyFlow >= 10;
            
            // Calculate damage sacrificed (health lost to kill this enemy)
            const damageSacrificed = enemyDamage;
            const isHighSacrifice = damageSacrificed >= 5;
            const isExtremeSacrifice = damageSacrificed >= 10;
            const isPerfectKill = damageSacrificed === 0;
            
            // Determine kill method efficiency
            const wasOneShot = enemy.initialHealth === enemy.initialHealth && playerDamage >= enemy.initialHealth;
            const wasEfficient = playerDamage >= enemyStrength * 0.8; // Dealt most damage in final blow
            const wasGrindingFight = playerDamage < enemyStrength * 0.3; // Long drawn out fight
            
            // Generate contextual verbs and descriptions
            let actionVerb = "eliminated";
            let enemyDescriptor = "";
            let contextualDescription = "";
            
            // Choose action verb based on kill circumstances
            if (wasOneShot) {
                if (isVeryStrongEnemy) {
                    actionVerb = "obliterated";
                } else if (isStrongEnemy) {
                    actionVerb = "annihilated";
                } else {
                    actionVerb = "executed";
                }
            } else if (isPerfectKill) {
                actionVerb = "outmaneuvered";
            } else if (isExtremeSacrifice) {
                actionVerb = "barely survived";
            } else if (wasGrindingFight) {
                actionVerb = "wore down";
            } else if (wasEfficient) {
                actionVerb = "dispatched";
            } else {
                actionVerb = "defeated";
            }
            
            // Generate enemy descriptors based on strength and flow
            if (isEliteEnemy) {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the raging titan";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the furious behemoth";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the formidable giant";
                } else {
                    enemyDescriptor = "the mighty fortress";
                }
            } else if (isVeryStrongEnemy) {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the berserk warrior";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the enraged brute";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the aggressive veteran";
                } else {
                    enemyDescriptor = "the hardened opponent";
                }
            } else if (isStrongEnemy) {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the frenzied fighter";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the rabid combatant";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the hostile adversary";
                } else {
                    enemyDescriptor = "the resilient foe";
                }
            } else {
                if (isBerserkEnemy) {
                    enemyDescriptor = "the wild scrapper";
                } else if (isEnragedEnemy) {
                    enemyDescriptor = "the maddened opponent";
                } else if (isAngryEnemy) {
                    enemyDescriptor = "the agitated enemy";
                } else {
                    enemyDescriptor = "the basic threat";
                }
            }
            
            // Add contextual descriptions based on sacrifice and method
            if (isPerfectKill) {
                if (isEliteEnemy) {
                    contextualDescription = " without taking a scratch - a masterful display";
                } else if (isStrongEnemy) {
                    contextualDescription = " flawlessly, untouched by retaliation";
                } else {
                    contextualDescription = " with surgical precision";
                }
            } else if (isExtremeSacrifice) {
                if (wasGrindingFight) {
                    contextualDescription = ` in a brutal war of attrition (${damageSacrificed} HP lost)`;
                } else {
                    contextualDescription = ` at great personal cost (${damageSacrificed} HP sacrificed)`;
                }
            } else if (isHighSacrifice) {
                contextualDescription = ` through sheer determination (${damageSacrificed} HP lost)`;
            } else if (wasOneShot) {
                if (isEliteEnemy) {
                    contextualDescription = " in a single, earth-shattering blow";
                } else if (isStrongEnemy) {
                    contextualDescription = " with one decisive strike";
                } else {
                    contextualDescription = " instantly";
                }
            } else if (wasGrindingFight) {
                contextualDescription = " after a prolonged engagement";
            } else if (wasEfficient) {
                contextualDescription = " with calculated efficiency";
            }
            
            // Special cases for dramatic effect
            if (isBerserkEnemy && isPerfectKill) {
                contextualDescription = " despite their berserk fury, emerging unscathed";
            } else if (isEliteEnemy && wasOneShot) {
                contextualDescription = " in a legendary display of overwhelming power";
            } else if (isAngryEnemy && isExtremeSacrifice) {
                contextualDescription = ` in a savage exchange of blows (${damageSacrificed} HP traded for victory)`;
            }
            
            // Construct the final message
            const playerSpan = `<span style="background-color: ${playerColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${player.name}</span>`;
            const enemySpan = `<span style="background-color: ${enemyColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${enemy.name}</span>`;
            
            return `${playerSpan} ${actionVerb} ${enemySpan}, ${enemyDescriptor}${contextualDescription}`;
        }

        /**
         * Updates the activity log display in the right panel.
         */
        function updateActivityLogDisplay() {
            const rightPanel = document.getElementById('rightPanel');
            rightPanel.innerHTML = ''; // Clear existing entries
            
            activityLog.forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'activity-log-entry';
                
                // Dim older entries
                if (index > 0) {
                    entryDiv.classList.add('dimmed');
                }
                
                if (entry.isMajorEvent) {
                    // Major event entry with warning symbol
                    entryDiv.style.backgroundColor = '#2a2a00'; // Dark yellow background
                    entryDiv.style.border = '1px solid #ffaa00'; // Orange border
                    entryDiv.style.padding = '4px';
                    entryDiv.style.borderRadius = '3px';
                    entryDiv.style.marginBottom = '2px';
                    
                    const warningSymbol = document.createElement('span');
                    warningSymbol.innerHTML = '⚠️ ';
                    warningSymbol.style.color = '#ffaa00';
                    warningSymbol.style.fontWeight = 'bold';
                    
                    const messageText = document.createElement('span');
                    messageText.innerHTML = entry.message;
                    messageText.style.color = '#ffffff';
                    
                    entryDiv.appendChild(warningSymbol);
                    entryDiv.appendChild(messageText);
                } else {
                    // Regular combat entry
                    const mainText = document.createElement('div');
                    mainText.innerHTML = `<span class="player-name" style="background-color: ${entry.playerColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${entry.playerName}</span> has killed <span class="enemy-name" style="background-color: ${entry.enemyColor}; color: #fff; padding: 2px 4px; border-radius: 3px;">${entry.enemyName}</span>`;
                    entryDiv.appendChild(mainText);
                }
                
                rightPanel.appendChild(entryDiv);
            });
        }

        /**
         * Sets up the color scheme for the level.
         */
        function setupColors() {
            COLOR_FLOOR = '#333333'; // Dark grey for playable floor tiles
            COLOR_WALL = '#000000'; // Black for walls (same as void)
        }

        /**
         * Initializes the game map with walls.
         */
        function initializeMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
        }

        /**
         * Generates procedural paths using a random walk algorithm.
         * @param {number} steps - The number of steps for the random walk.
         */
        function generatePaths(steps) {
            console.log('Starting map generation:', { steps, mapWidth: dynamicMapWidth, mapHeight: dynamicMapHeight });
            
            // Initialize starting point in the middle
            let currentX = Math.floor(dynamicMapWidth / 2);
            let currentY = Math.floor(dynamicMapHeight / 2);

            currentX = Math.max(1, Math.min(dynamicMapWidth - 2, currentX));
            currentY = Math.max(1, Math.min(dynamicMapHeight - 2, currentY));

            // Create initial map
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Start with a floor tile in the middle
            gameMap[currentY][currentX] = TILE_FLOOR;

            // Generate paths
            for (let i = 0; i < steps; i++) {
                // Pick a random direction (0: up, 1: right, 2: down, 3: left)
                const direction = Math.floor(Math.random() * 4);
                let nextX = currentX;
                let nextY = currentY;

                switch (direction) {
                    case 0: nextY--; break; // Up
                    case 1: nextX++; break; // Right
                    case 2: nextY++; break; // Down
                    case 3: nextX--; break; // Left
                }

                // Check bounds and make floor tile if valid
                if (nextX >= 1 && nextX < dynamicMapWidth - 1 && nextY >= 1 && nextY < dynamicMapHeight - 1) {
                    gameMap[nextY][nextX] = TILE_FLOOR;
                    currentX = nextX;
                    currentY = nextY;
                }
            }
        }

        /**
         * Gets the current world configuration
         * @returns {object} The current world configuration
         */
        function getCurrentWorld() {
            return WORLDS[currentWorld];
        }

        /**
         * Checks if a world can be unlocked based on total score
         * @param {number} worldNumber - The world number to check
         * @returns {boolean} True if the world can be unlocked
         */
        function canUnlockWorld(worldNumber) {
            if (!WORLDS[worldNumber]) return false;
            return totalPlayerScore >= WORLDS[worldNumber].unlockRequirement;
        }

        /**
         * Unlocks worlds based on current total score
         */
        function checkAndUnlockWorlds() {
            for (let worldNum in WORLDS) {
                const worldNumber = parseInt(worldNum);
                if (!unlockedWorlds.includes(worldNumber) && canUnlockWorld(worldNumber)) {
                    unlockedWorlds.push(worldNumber);
                    console.log(`World ${worldNumber} (${WORLDS[worldNumber].name}) unlocked!`);
                }
            }
        }

        /**
         * Sets up colors for the current world
         */
        function setupWorldColors() {
            const world = getCurrentWorld();
            COLOR_FLOOR = world.colors.floor;
            COLOR_WALL = world.colors.wall;
            FIXED_COLOR_STAIRS = world.colors.stairs;
            FIXED_COLOR_PLAYER = world.colors.player;
            FIXED_COLOR_ENEMY = world.colors.enemy;
            
            // Update the background color to match the world's wall color
            updateBackgroundColor();
        }

        /**
         * Updates the game wrapper background color to match the current world theme
         */
        function updateBackgroundColor() {
            const world = getCurrentWorld();
            const gameWrapper = document.querySelector('.game-wrapper');
            if (gameWrapper) {
                gameWrapper.style.backgroundColor = world.colors.wall;
            }
            
            // Also update CSS custom properties for media queries
            document.documentElement.style.setProperty('--world-wall-color', world.colors.wall);
        }

        /**
         * Generates a desert-themed map with circular oasis rooms
         */
        /**
         * Generates a desert-themed map with irregular islands and narrow bridges
         */
        /**
         * Generates a basic map with one long hallway and side chambers
         */
        function generateBasicMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create main long hallway running horizontally through the center
            const hallwayY = Math.floor(dynamicMapHeight / 2);
            const hallwayWidth = 3; // 3-tile wide hallway
            
            // Create the main hallway
            for (let y = hallwayY - 1; y <= hallwayY + 1; y++) {
                for (let x = 2; x < dynamicMapWidth - 2; x++) {
                    if (y >= 0 && y < dynamicMapHeight) {
                        gameMap[y][x] = TILE_FLOOR;
                    }
                }
            }
            
            // Add side chambers branching off the main hallway
            const numChambers = Math.floor(dynamicMapWidth / 8); // One chamber every 8 tiles
            
            for (let i = 0; i < numChambers; i++) {
                const chamberCenterX = 8 + i * Math.floor((dynamicMapWidth - 16) / numChambers);
                const side = i % 2 === 0 ? -1 : 1; // Alternate sides
                
                const chamberWidth = 4 + Math.floor(Math.random() * 3); // Width 4-6
                const chamberHeight = 3 + Math.floor(Math.random() * 3); // Height 3-5
                
                // Create connecting corridor from hallway to chamber
                const corridorLength = 2 + Math.floor(Math.random() * 3); // Length 2-4
                for (let c = 1; c <= corridorLength; c++) {
                    const corridorY = hallwayY + (side * c);
                    if (corridorY >= 0 && corridorY < dynamicMapHeight) {
                        gameMap[corridorY][chamberCenterX] = TILE_FLOOR;
                    }
                }
                
                // Create the chamber
                const chamberY = hallwayY + (side * (corridorLength + Math.floor(chamberHeight / 2)));
                for (let dy = -Math.floor(chamberHeight / 2); dy <= Math.floor(chamberHeight / 2); dy++) {
                    for (let dx = -Math.floor(chamberWidth / 2); dx <= Math.floor(chamberWidth / 2); dx++) {
                        const x = chamberCenterX + dx;
                        const y = chamberY + dy;
                        if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                            gameMap[y][x] = TILE_FLOOR;
                        }
                    }
                }
            }
        }

        function generateDesertMap() {
            // Ant colony style - multiple chambers connected by narrow tunnels
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            const numChambers = Math.max(6, Math.floor(dynamicMapWidth * dynamicMapHeight / 30));
            const chambers = [];
            
            // Create main chambers (ant colony rooms)
            for (let i = 0; i < numChambers; i++) {
                let attempts = 0;
                let chamberX, chamberY;
                
                do {
                    chamberX = 4 + Math.floor(Math.random() * (dynamicMapWidth - 8));
                    chamberY = 4 + Math.floor(Math.random() * (dynamicMapHeight - 8));
                    attempts++;
                } while (attempts < 50 && chambers.some(chamber => 
                    Math.abs(chamber.x - chamberX) < 8 || Math.abs(chamber.y - chamberY) < 8
                ));
                
                const chamberType = Math.random();
                let width, height;
                
                if (chamberType < 0.3) {
                    // Large nursery chamber
                    width = 6 + Math.floor(Math.random() * 3);
                    height = 6 + Math.floor(Math.random() * 3);
                } else if (chamberType < 0.6) {
                    // Medium storage chamber
                    width = 4 + Math.floor(Math.random() * 2);
                    height = 4 + Math.floor(Math.random() * 2);
                } else {
                    // Small worker chamber
                    width = 3 + Math.floor(Math.random() * 2);
                    height = 3 + Math.floor(Math.random() * 2);
                }
                
                chambers.push({ x: chamberX, y: chamberY, width, height, type: chamberType });
                
                // Create oval-shaped chamber
                for (let dy = -Math.floor(height/2); dy <= Math.floor(height/2); dy++) {
                    for (let dx = -Math.floor(width/2); dx <= Math.floor(width/2); dx++) {
                        const normalizedX = dx / (width/2);
                        const normalizedY = dy / (height/2);
                        const distance = normalizedX * normalizedX + normalizedY * normalizedY;
                        
                        if (distance <= 1.0 + Math.random() * 0.2) { // Slightly irregular edges
                            const x = chamberX + dx;
                            const y = chamberY + dy;
                            if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                gameMap[y][x] = TILE_FLOOR;
                            }
                        }
                    }
                }
            }
            
            // Create tunnel network connecting all chambers
            const tunnelNetwork = [];
            
            // Connect each chamber to at least 2 others for redundancy (like real ant colonies)
            for (let i = 0; i < chambers.length; i++) {
                const chamber = chambers[i];
                const connections = [];
                
                // Find 2-3 closest chambers to connect to
                const otherChambers = chambers.filter((_, idx) => idx !== i);
                otherChambers.sort((a, b) => {
                    const distA = Math.abs(a.x - chamber.x) + Math.abs(a.y - chamber.y);
                    const distB = Math.abs(b.x - chamber.x) + Math.abs(b.y - chamber.y);
                    return distA - distB;
                });
                
                // Connect to 2-3 nearest chambers
                const numConnections = Math.min(2 + Math.floor(Math.random() * 2), otherChambers.length);
                for (let j = 0; j < numConnections; j++) {
                    connections.push(otherChambers[j]);
                }
                
                // Create narrow tunnels (1 tile wide like ant tunnels)
                connections.forEach(targetChamber => {
                    let currentX = chamber.x;
                    let currentY = chamber.y;
                    
                    // Create winding tunnel path
                    while (currentX !== targetChamber.x || currentY !== targetChamber.y) {
                        if (currentX >= 0 && currentX < dynamicMapWidth && 
                            currentY >= 0 && currentY < dynamicMapHeight) {
                            gameMap[currentY][currentX] = TILE_FLOOR;
                        }
                        
                        // Add some randomness to create more natural ant-like tunnels
                        if (Math.random() < 0.7) {
                            // Move toward target most of the time
                            if (Math.abs(currentX - targetChamber.x) > Math.abs(currentY - targetChamber.y)) {
                                currentX += currentX < targetChamber.x ? 1 : -1;
                            } else {
                                currentY += currentY < targetChamber.y ? 1 : -1;
                            }
                        } else {
                            // Occasionally take a random direction for more organic paths
                            if (Math.random() < 0.5 && currentX !== targetChamber.x) {
                                currentX += currentX < targetChamber.x ? 1 : -1;
                            } else if (currentY !== targetChamber.y) {
                                currentY += currentY < targetChamber.y ? 1 : -1;
                            }
                        }
                    }
                });
            }
            
            // Add some dead-end tunnels for authenticity (ant colonies have many dead ends)
            const numDeadEnds = Math.floor(chambers.length / 2);
            for (let i = 0; i < numDeadEnds; i++) {
                const chamber = chambers[Math.floor(Math.random() * chambers.length)];
                const direction = Math.floor(Math.random() * 4); // 0=up, 1=right, 2=down, 3=left
                const length = 2 + Math.floor(Math.random() * 4);
                
                let currentX = chamber.x;
                let currentY = chamber.y;
                
                for (let step = 0; step < length; step++) {
                    switch(direction) {
                        case 0: currentY--; break;
                        case 1: currentX++; break;
                        case 2: currentY++; break;
                        case 3: currentX--; break;
                    }
                    
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                }
            }
        }

        /**
         * Generates an ice-themed map with extremely narrow caves
         */
        function generateIceMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create extremely narrow cave system - mostly 1-tile wide passages
            const numMainPaths = Math.max(3, Math.floor(dynamicMapWidth * dynamicMapHeight / 100));
            const paths = [];
            
            // Start from random positions along edges
            for (let i = 0; i < numMainPaths; i++) {
                let startX, startY;
                const edge = Math.floor(Math.random() * 4);
                
                switch(edge) {
                    case 0: // Top edge
                        startX = Math.floor(Math.random() * dynamicMapWidth);
                        startY = 1;
                        break;
                    case 1: // Right edge
                        startX = dynamicMapWidth - 2;
                        startY = Math.floor(Math.random() * dynamicMapHeight);
                        break;
                    case 2: // Bottom edge
                        startX = Math.floor(Math.random() * dynamicMapWidth);
                        startY = dynamicMapHeight - 2;
                        break;
                    case 3: // Left edge
                        startX = 1;
                        startY = Math.floor(Math.random() * dynamicMapHeight);
                        break;
                }
                
                paths.push({ x: startX, y: startY });
                
                // Create winding narrow cave from this starting point
                let currentX = startX;
                let currentY = startY;
                const pathLength = Math.floor(dynamicMapWidth * dynamicMapHeight / 8);
                let direction = Math.floor(Math.random() * 4); // 0=up, 1=right, 2=down, 3=left
                
                for (let step = 0; step < pathLength; step++) {
                    // Place floor tile
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                    
                    // Randomly change direction to create winding paths
                    if (Math.random() < 0.15) {
                        direction = Math.floor(Math.random() * 4);
                    }
                    
                    // Move in current direction
                    let nextX = currentX;
                    let nextY = currentY;
                    
                    switch(direction) {
                        case 0: nextY--; break; // Up
                        case 1: nextX++; break; // Right
                        case 2: nextY++; break; // Down
                        case 3: nextX--; break; // Left
                    }
                    
                    // Check bounds and change direction if hitting edge
                    if (nextX <= 0 || nextX >= dynamicMapWidth - 1 || 
                        nextY <= 0 || nextY >= dynamicMapHeight - 1) {
                        direction = (direction + 1 + Math.floor(Math.random() * 2)) % 4;
                        continue;
                    }
                    
                    currentX = nextX;
                    currentY = nextY;
                    
                    // Occasionally create very small alcoves (1-2 tiles)
                    if (Math.random() < 0.08) {
                        const alcoveDirection = (direction + 1 + Math.floor(Math.random() * 2)) % 4;
                        let alcoveX = currentX;
                        let alcoveY = currentY;
                        
                        switch(alcoveDirection) {
                            case 0: alcoveY--; break;
                            case 1: alcoveX++; break;
                            case 2: alcoveY++; break;
                            case 3: alcoveX--; break;
                        }
                        
                        if (alcoveX > 0 && alcoveX < dynamicMapWidth - 1 && 
                            alcoveY > 0 && alcoveY < dynamicMapHeight - 1) {
                            gameMap[alcoveY][alcoveX] = TILE_FLOOR;
                            
                            // Rarely add a second tile to the alcove
                            if (Math.random() < 0.3) {
                                switch(alcoveDirection) {
                                    case 0: alcoveY--; break;
                                    case 1: alcoveX++; break;
                                    case 2: alcoveY++; break;
                                    case 3: alcoveX--; break;
                                }
                                
                                if (alcoveX > 0 && alcoveX < dynamicMapWidth - 1 && 
                                    alcoveY > 0 && alcoveY < dynamicMapHeight - 1) {
                                    gameMap[alcoveY][alcoveX] = TILE_FLOOR;
                                }
                            }
                        }
                    }
                }
            }
            
            // Create connections between paths where they get close
            for (let y = 1; y < dynamicMapHeight - 1; y++) {
                for (let x = 1; x < dynamicMapWidth - 1; x++) {
                    if (gameMap[y][x] === TILE_FLOOR) {
                        // Look for nearby floor tiles to potentially connect to
                        const searchRadius = 3;
                        for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                            for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                                if (Math.abs(dx) + Math.abs(dy) === searchRadius && // Only check at exact distance
                                    Math.random() < 0.1) { // Low chance to keep caves narrow
                                    
                                    const checkX = x + dx;
                                    const checkY = y + dy;
                                    
                                    if (checkX > 0 && checkX < dynamicMapWidth - 1 && 
                                        checkY > 0 && checkY < dynamicMapHeight - 1 && 
                                        gameMap[checkY][checkX] === TILE_FLOOR) {
                                        
                                        // Create narrow connecting tunnel
                                        let connectX = x;
                                        let connectY = y;
                                        
                                        while (connectX !== checkX || connectY !== checkY) {
                                            if (connectX !== checkX) {
                                                connectX += connectX < checkX ? 1 : -1;
                                            } else if (connectY !== checkY) {
                                                connectY += connectY < checkY ? 1 : -1;
                                            }
                                            
                                            if (connectX > 0 && connectX < dynamicMapWidth - 1 && 
                                                connectY > 0 && connectY < dynamicMapHeight - 1) {
                                                gameMap[connectY][connectX] = TILE_FLOOR;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        /**
         * Generates a forest-themed map with lots of tiny rooms
         */
        function generateForestMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create many tiny rooms (like clearings in a dense forest)
            const numTinyRooms = Math.floor(dynamicMapWidth * dynamicMapHeight / 15); // Many small rooms
            const rooms = [];
            
            for (let i = 0; i < numTinyRooms; i++) {
                let attempts = 0;
                let roomX, roomY;
                let roomSize;
                
                do {
                    roomX = 2 + Math.floor(Math.random() * (dynamicMapWidth - 4));
                    roomY = 2 + Math.floor(Math.random() * (dynamicMapHeight - 4));
                    roomSize = 1 + Math.floor(Math.random() * 2); // Size 1-2 (very tiny!)
                    attempts++;
                } while (attempts < 30 && rooms.some(room => 
                    Math.abs(room.x - roomX) < 4 && Math.abs(room.y - roomY) < 4
                ));
                
                if (attempts < 30) {
                    rooms.push({ x: roomX, y: roomY, size: roomSize });
                    
                    // Create tiny circular room
                    for (let dy = -roomSize; dy <= roomSize; dy++) {
                        for (let dx = -roomSize; dx <= roomSize; dx++) {
                            const distance = Math.abs(dx) + Math.abs(dy);
                            if (distance <= roomSize) {
                                const x = roomX + dx;
                                const y = roomY + dy;
                                if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                    gameMap[y][x] = TILE_FLOOR;
                                }
                            }
                        }
                    }
                }
            }
            
            // Create a network of narrow paths connecting the tiny rooms
            // Sort rooms by distance to create a minimum spanning tree-like connection
            const connected = new Set();
            const connections = [];
            
            if (rooms.length > 0) {
                connected.add(0); // Start with first room
                
                while (connected.size < rooms.length) {
                    let minDistance = Infinity;
                    let bestConnection = null;
                    
                    // Find closest unconnected room to any connected room
                    for (let connectedIdx of connected) {
                        for (let i = 0; i < rooms.length; i++) {
                            if (!connected.has(i)) {
                                const distance = Math.abs(rooms[connectedIdx].x - rooms[i].x) + 
                                               Math.abs(rooms[connectedIdx].y - rooms[i].y);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    bestConnection = { from: connectedIdx, to: i };
                                }
                            }
                        }
                    }
                    
                    if (bestConnection) {
                        connected.add(bestConnection.to);
                        connections.push(bestConnection);
                    } else {
                        break; // No more connections possible
                    }
                }
            }
            
            // Create the connecting paths
            connections.forEach(connection => {
                const startRoom = rooms[connection.from];
                const endRoom = rooms[connection.to];
                
                let currentX = startRoom.x;
                let currentY = startRoom.y;
                
                // Create narrow winding path
                while (currentX !== endRoom.x || currentY !== endRoom.y) {
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                    
                    // Add organic curves to paths
                    if (Math.random() < 0.8) {
                        // Move toward target most of the time
                        if (Math.abs(currentX - endRoom.x) > Math.abs(currentY - endRoom.y)) {
                            currentX += currentX < endRoom.x ? 1 : -1;
                        } else {
                            currentY += currentY < endRoom.y ? 1 : -1;
                        }
                    } else {
                        // Occasionally take a detour for natural feel
                        const randomDir = Math.floor(Math.random() * 4);
                        switch(randomDir) {
                            case 0: if (currentY > 1) currentY--; break;
                            case 1: if (currentX < dynamicMapWidth - 2) currentX++; break;
                            case 2: if (currentY < dynamicMapHeight - 2) currentY++; break;
                            case 3: if (currentX > 1) currentX--; break;
                        }
                    }
                }
            });
            
            // Add some additional random connections for redundancy (like animal trails)
            const numExtraConnections = Math.floor(rooms.length / 4);
            for (let i = 0; i < numExtraConnections; i++) {
                const room1 = rooms[Math.floor(Math.random() * rooms.length)];
                const room2 = rooms[Math.floor(Math.random() * rooms.length)];
                
                if (room1 !== room2) {
                    const distance = Math.abs(room1.x - room2.x) + Math.abs(room1.y - room2.y);
                    
                    // Only connect if reasonably close
                    if (distance < Math.min(dynamicMapWidth, dynamicMapHeight) / 2) {
                        let currentX = room1.x;
                        let currentY = room1.y;
                        
                        while (currentX !== room2.x || currentY !== room2.y) {
                            if (currentX >= 0 && currentX < dynamicMapWidth && 
                                currentY >= 0 && currentY < dynamicMapHeight) {
                                gameMap[currentY][currentX] = TILE_FLOOR;
                            }
                            
                            if (currentX !== room2.x) currentX += currentX < room2.x ? 1 : -1;
                            if (currentY !== room2.y && Math.random() < 0.7) currentY += currentY < room2.y ? 1 : -1;
                        }
                    }
                }
            }
        }

        /**
         * Generates a crystal-themed map with a bunch of houses (rectangular structures)
         */
        function generateCrystalMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create a village/town layout with many house-like rectangular structures
            const numHouses = Math.max(8, Math.floor(dynamicMapWidth * dynamicMapHeight / 25));
            const houses = [];
            
            for (let i = 0; i < numHouses; i++) {
                let attempts = 0;
                let houseX, houseY, houseWidth, houseHeight;
                
                do {
                    houseX = 2 + Math.floor(Math.random() * (dynamicMapWidth - 8));
                    houseY = 2 + Math.floor(Math.random() * (dynamicMapHeight - 8));
                    houseWidth = 3 + Math.floor(Math.random() * 4); // Width 3-6
                    houseHeight = 3 + Math.floor(Math.random() * 4); // Height 3-6
                    attempts++;
                } while (attempts < 50 && houses.some(house => 
                    !(houseX + houseWidth + 2 < house.x || 
                      house.x + house.width + 2 < houseX || 
                      houseY + houseHeight + 2 < house.y || 
                      house.y + house.height + 2 < houseY)
                ));
                
                if (attempts < 50 && 
                    houseX + houseWidth < dynamicMapWidth - 1 && 
                    houseY + houseHeight < dynamicMapHeight - 1) {
                    
                    houses.push({ 
                        x: houseX, 
                        y: houseY, 
                        width: houseWidth, 
                        height: houseHeight 
                    });
                    
                    // Create rectangular house structure
                    for (let dy = 0; dy < houseHeight; dy++) {
                        for (let dx = 0; dx < houseWidth; dx++) {
                            const x = houseX + dx;
                            const y = houseY + dy;
                            
                            if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                gameMap[y][x] = TILE_FLOOR;
                            }
                        }
                    }
                    
                    // Add some internal structure to larger houses
                    if (houseWidth >= 5 && houseHeight >= 5) {
                        // Add internal walls to create rooms
                        const numInternalWalls = 1 + Math.floor(Math.random() * 2);
                        
                        for (let w = 0; w < numInternalWalls; w++) {
                            if (Math.random() < 0.5 && houseWidth >= 5) {
                                // Vertical internal wall
                                const wallX = houseX + 2 + Math.floor(Math.random() * (houseWidth - 4));
                                for (let dy = 1; dy < houseHeight - 1; dy++) {
                                    const y = houseY + dy;
                                    if (Math.random() < 0.7) { // Leave some gaps for doors
                                        gameMap[y][wallX] = TILE_WALL;
                                    }
                                }
                            }
                            
                            if (Math.random() < 0.5 && houseHeight >= 5) {
                                // Horizontal internal wall
                                const wallY = houseY + 2 + Math.floor(Math.random() * (houseHeight - 4));
                                for (let dx = 1; dx < houseWidth - 1; dx++) {
                                    const x = houseX + dx;
                                    if (Math.random() < 0.7) { // Leave some gaps for doors
                                        gameMap[wallY][x] = TILE_WALL;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Create street/path network connecting houses
            // First, create main streets (horizontal and vertical)
            const numMainStreets = Math.max(2, Math.floor(Math.max(dynamicMapWidth, dynamicMapHeight) / 15));
            
            // Vertical main streets
            for (let i = 0; i < Math.floor(numMainStreets / 2); i++) {
                const streetX = Math.floor((i + 1) * dynamicMapWidth / (Math.floor(numMainStreets / 2) + 1));
                
                for (let y = 0; y < dynamicMapHeight; y++) {
                    if (streetX >= 0 && streetX < dynamicMapWidth) {
                        // Only place street if not inside a house
                        let insideHouse = false;
                        for (let house of houses) {
                            if (streetX >= house.x && streetX < house.x + house.width &&
                                y >= house.y && y < house.y + house.height) {
                                insideHouse = true;
                                break;
                            }
                        }
                        
                        if (!insideHouse) {
                            gameMap[y][streetX] = TILE_FLOOR;
                        }
                    }
                }
            }
            
            // Horizontal main streets
            for (let i = 0; i < Math.ceil(numMainStreets / 2); i++) {
                const streetY = Math.floor((i + 1) * dynamicMapHeight / (Math.ceil(numMainStreets / 2) + 1));
                
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (streetY >= 0 && streetY < dynamicMapHeight) {
                        // Only place street if not inside a house
                        let insideHouse = false;
                        for (let house of houses) {
                            if (x >= house.x && x < house.x + house.width &&
                                streetY >= house.y && streetY < house.y + house.height) {
                                insideHouse = true;
                                break;
                            }
                        }
                        
                        if (!insideHouse) {
                            gameMap[streetY][x] = TILE_FLOOR;
                        }
                    }
                }
            }
            
            // Connect each house to the nearest street with a path
            houses.forEach(house => {
                const houseCenterX = house.x + Math.floor(house.width / 2);
                const houseCenterY = house.y + Math.floor(house.height / 2);
                
                // Find nearest street tile
                let nearestStreetX = houseCenterX;
                let nearestStreetY = houseCenterY;
                let minDistance = Infinity;
                
                for (let y = 0; y < dynamicMapHeight; y++) {
                    for (let x = 0; x < dynamicMapWidth; x++) {
                        if (gameMap[y][x] === TILE_FLOOR) {
                            // Check if this is a street (not inside any house)
                            let isStreet = true;
                            for (let otherHouse of houses) {
                                if (x >= otherHouse.x && x < otherHouse.x + otherHouse.width &&
                                    y >= otherHouse.y && y < otherHouse.y + otherHouse.height) {
                                    isStreet = false;
                                    break;
                                }
                            }
                            
                            if (isStreet) {
                                const distance = Math.abs(x - houseCenterX) + Math.abs(y - houseCenterY);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    nearestStreetX = x;
                                    nearestStreetY = y;
                                }
                            }
                        }
                    }
                }
                
                // Create path from house to street
                let currentX = houseCenterX;
                let currentY = houseCenterY;
                
                while (currentX !== nearestStreetX || currentY !== nearestStreetY) {
                    if (currentX >= 0 && currentX < dynamicMapWidth && 
                        currentY >= 0 && currentY < dynamicMapHeight) {
                        gameMap[currentY][currentX] = TILE_FLOOR;
                    }
                    
                    if (currentX !== nearestStreetX) {
                        currentX += currentX < nearestStreetX ? 1 : -1;
                    } else if (currentY !== nearestStreetY) {
                        currentY += currentY < nearestStreetY ? 1 : -1;
                    }
                }
            });
        }

        /**
         * Generates a volcano-themed map with spiral tubes and chambers
         */
        function generateVolcanoMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create spiral lava tubes emanating from central chambers
            const numSpiralCenters = Math.max(2, Math.floor(Math.min(dynamicMapWidth, dynamicMapHeight) / 20));
            const spiralCenters = [];
            
            for (let i = 0; i < numSpiralCenters; i++) {
                const centerX = Math.floor(dynamicMapWidth * (0.2 + Math.random() * 0.6));
                const centerY = Math.floor(dynamicMapHeight * (0.2 + Math.random() * 0.6));
                
                spiralCenters.push({ x: centerX, y: centerY });
                
                // Create central magma chamber
                const chamberSize = 3 + Math.floor(Math.random() * 3); // Size 3-5
                for (let dy = -chamberSize; dy <= chamberSize; dy++) {
                    for (let dx = -chamberSize; dx <= chamberSize; dx++) {
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance <= chamberSize * (0.8 + Math.random() * 0.4)) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                gameMap[y][x] = TILE_FLOOR;
                            }
                        }
                    }
                }
                
                // Create multiple spiral tubes from this center
                const numSpirals = 2 + Math.floor(Math.random() * 3); // 2-4 spirals per center
                
                for (let s = 0; s < numSpirals; s++) {
                    const startAngle = (s / numSpirals) * 2 * Math.PI + Math.random() * 0.5; // Offset each spiral
                    const spiralDirection = Math.random() < 0.5 ? 1 : -1; // Clockwise or counterclockwise
                    const spiralTightness = 0.05 + Math.random() * 0.05; // How tight the spiral is
                    const maxRadius = Math.min(dynamicMapWidth, dynamicMapHeight) / 3;
                    
                    let currentAngle = startAngle;
                    let currentRadius = 2;
                    
                    while (currentRadius < maxRadius) {
                        const x = Math.floor(centerX + Math.cos(currentAngle) * currentRadius);
                        const y = Math.floor(centerY + Math.sin(currentAngle) * currentRadius);
                        
                        if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                            gameMap[y][x] = TILE_FLOOR;
                            
                            // Make the tube slightly wider occasionally
                            if (Math.random() < 0.3) {
                                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                                for (let [dx, dy] of directions) {
                                    const wideX = x + dx;
                                    const wideY = y + dy;
                                    if (wideX >= 0 && wideX < dynamicMapWidth && 
                                        wideY >= 0 && wideY < dynamicMapHeight && 
                                        Math.random() < 0.5) {
                                        gameMap[wideY][wideX] = TILE_FLOOR;
                                    }
                                }
                            }
                            
                            // Occasionally create small side chambers
                            if (Math.random() < 0.08 && currentRadius > 5) {
                                const sideAngle = currentAngle + (Math.PI / 2) * (Math.random() < 0.5 ? 1 : -1);
                                const sideDistance = 2 + Math.floor(Math.random() * 3);
                                
                                for (let d = 1; d <= sideDistance; d++) {
                                    const sideX = Math.floor(x + Math.cos(sideAngle) * d);
                                    const sideY = Math.floor(y + Math.sin(sideAngle) * d);
                                    
                                    if (sideX >= 0 && sideX < dynamicMapWidth && 
                                        sideY >= 0 && sideY < dynamicMapHeight) {
                                        gameMap[sideY][sideX] = TILE_FLOOR;
                                        
                                        // Create small chamber at the end
                                        if (d === sideDistance) {
                                            const chamberRadius = 1 + Math.floor(Math.random() * 2);
                                            for (let cdy = -chamberRadius; cdy <= chamberRadius; cdy++) {
                                                for (let cdx = -chamberRadius; cdx <= chamberRadius; cdx++) {
                                                    if (Math.abs(cdx) + Math.abs(cdy) <= chamberRadius) {
                                                        const cx = sideX + cdx;
                                                        const cy = sideY + cdy;
                                                        if (cx >= 0 && cx < dynamicMapWidth && 
                                                            cy >= 0 && cy < dynamicMapHeight) {
                                                            gameMap[cy][cx] = TILE_FLOOR;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Advance the spiral
                        currentAngle += spiralDirection * spiralTightness;
                        currentRadius += 0.3; // Gradual radius increase
                    }
                }
            }
            
            // Connect spiral centers with direct lava tubes if they're not too far apart
            for (let i = 0; i < spiralCenters.length - 1; i++) {
                const center1 = spiralCenters[i];
                const center2 = spiralCenters[i + 1];
                
                const distance = Math.sqrt((center2.x - center1.x) ** 2 + (center2.y - center1.y) ** 2);
                
                if (distance < Math.min(dynamicMapWidth, dynamicMapHeight) * 0.6) {
                    // Create connecting lava tube
                    let currentX = center1.x;
                    let currentY = center1.y;
                    
                    while (currentX !== center2.x || currentY !== center2.y) {
                        // Create wider connecting tube
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const x = currentX + dx;
                                const y = currentY + dy;
                                if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                                    gameMap[y][x] = TILE_FLOOR;
                                }
                            }
                        }
                        
                        // Move towards target with some randomness
                        if (Math.random() < 0.8) {
                            if (Math.abs(currentX - center2.x) > Math.abs(currentY - center2.y)) {
                                currentX += currentX < center2.x ? 1 : -1;
                            } else {
                                currentY += currentY < center2.y ? 1 : -1;
                            }
                        } else {
                            // Random movement for more organic tubes
                            const randomDir = Math.floor(Math.random() * 4);
                            switch(randomDir) {
                                case 0: if (currentY > 1) currentY--; break;
                                case 1: if (currentX < dynamicMapWidth - 2) currentX++; break;
                                case 2: if (currentY < dynamicMapHeight - 2) currentY++; break;
                                case 3: if (currentX > 1) currentX--; break;
                            }
                        }
                    }
                }
            }
        }

        /**
         * Generates a cyber-themed map with circuit board pattern
         */
        function generateCyberMap() {
            gameMap = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(TILE_WALL));
            
            // Create a circuit board-like pattern with components and traces
            const componentSpacing = 8;
            const components = [];
            
            // Place circuit components (CPU, RAM, etc.) in a grid-like pattern
            for (let y = componentSpacing / 2; y < dynamicMapHeight - componentSpacing / 2; y += componentSpacing) {
                for (let x = componentSpacing / 2; x < dynamicMapWidth - componentSpacing / 2; x += componentSpacing) {
                    if (Math.random() < 0.7) { // Not every grid position gets a component
                        const componentType = Math.random();
                        let componentWidth, componentHeight;
                        
                        if (componentType < 0.3) {
                            // Large CPU-like component
                            componentWidth = 4 + Math.floor(Math.random() * 2); // 4-5 wide
                            componentHeight = 4 + Math.floor(Math.random() * 2); // 4-5 tall
                        } else if (componentType < 0.6) {
                            // Medium RAM-like component
                            componentWidth = 2 + Math.floor(Math.random() * 2); // 2-3 wide
                            componentHeight = 3 + Math.floor(Math.random() * 3); // 3-5 tall
                        } else {
                            // Small chip component
                            componentWidth = 2 + Math.floor(Math.random() * 2); // 2-3 wide
                            componentHeight = 2 + Math.floor(Math.random() * 2); // 2-3 tall
                        }
                        
                        // Center the component at the grid position
                        const compX = x - Math.floor(componentWidth / 2);
                        const compY = y - Math.floor(componentHeight / 2);
                        
                        if (compX >= 0 && compY >= 0 && 
                            compX + componentWidth < dynamicMapWidth && 
                            compY + componentHeight < dynamicMapHeight) {
                            
                            components.push({
                                x: compX,
                                y: compY,
                                width: componentWidth,
                                height: componentHeight,
                                centerX: x,
                                centerY: y,
                                type: componentType < 0.3 ? 'cpu' : (componentType < 0.6 ? 'ram' : 'chip')
                            });
                            
                            // Create the component area
                            for (let dy = 0; dy < componentHeight; dy++) {
                                for (let dx = 0; dx < componentWidth; dx++) {
                                    gameMap[compY + dy][compX + dx] = TILE_FLOOR;
                                }
                            }
                            
                            // Add internal structure for larger components
                            if (componentWidth >= 4 && componentHeight >= 4) {
                                // Add internal pathways like a CPU
                                const internalSpacing = 2;
                                for (let iy = compY + 1; iy < compY + componentHeight - 1; iy += internalSpacing) {
                                    for (let ix = compX + 1; ix < compX + componentWidth - 1; ix++) {
                                        if (Math.random() < 0.6) {
                                            gameMap[iy][ix] = TILE_WALL; // Internal walls
                                        }
                                    }
                                }
                                for (let ix = compX + 1; ix < compX + componentWidth - 1; ix += internalSpacing) {
                                    for (let iy = compY + 1; iy < compY + componentHeight - 1; iy++) {
                                        if (Math.random() < 0.6) {
                                            gameMap[iy][ix] = TILE_WALL; // Internal walls
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Create circuit traces (connections) between components
            const traces = [];
            
            // Horizontal traces
            for (let y = 0; y < dynamicMapHeight; y += componentSpacing / 2) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    // Check if this position isn't inside a component
                    let insideComponent = false;
                    for (let comp of components) {
                        if (x >= comp.x && x < comp.x + comp.width &&
                            y >= comp.y && y < comp.y + comp.height) {
                            insideComponent = true;
                            break;
                        }
                    }
                    
                    if (!insideComponent && Math.random() < 0.8) {
                        gameMap[y][x] = TILE_FLOOR;
                        traces.push({ x, y, type: 'horizontal' });
                    }
                }
            }
            
            // Vertical traces
            for (let x = 0; x < dynamicMapWidth; x += componentSpacing / 2) {
                for (let y = 0; y < dynamicMapHeight; y++) {
                    // Check if this position isn't inside a component
                    let insideComponent = false;
                    for (let comp of components) {
                        if (x >= comp.x && x < comp.x + comp.width &&
                            y >= comp.y && y < comp.y + comp.height) {
                            insideComponent = true;
                            break;
                        }
                    }
                    
                    if (!insideComponent && Math.random() < 0.8) {
                        gameMap[y][x] = TILE_FLOOR;
                        traces.push({ x, y, type: 'vertical' });
                    }
                }
            }
            
            // Create data pathways - wider traces connecting major components
            const majorComponents = components.filter(comp => comp.type === 'cpu' || comp.type === 'ram');
            
            for (let i = 0; i < majorComponents.length - 1; i++) {
                const comp1 = majorComponents[i];
                const comp2 = majorComponents[i + 1];
                
                // Create wider data bus between major components
                let currentX = comp1.centerX;
                let currentY = comp1.centerY;
                
                while (currentX !== comp2.centerX || currentY !== comp2.centerY) {
                    // Create 3-wide data bus
                    for (let offset = -1; offset <= 1; offset++) {
                        let busX = currentX;
                        let busY = currentY + offset;
                        
                        // If moving vertically, offset horizontally instead
                        if (Math.abs(currentY - comp2.centerY) > Math.abs(currentX - comp2.centerX)) {
                            busX = currentX + offset;
                            busY = currentY;
                        }
                        
                        if (busX >= 0 && busX < dynamicMapWidth && 
                            busY >= 0 && busY < dynamicMapHeight) {
                            
                            // Don't overwrite component interiors
                            let insideComponent = false;
                            for (let comp of components) {
                                if (busX >= comp.x && busX < comp.x + comp.width &&
                                    busY >= comp.y && busY < comp.y + comp.height) {
                                    insideComponent = true;
                                    break;
                                }
                            }
                            
                            if (!insideComponent) {
                                gameMap[busY][busX] = TILE_FLOOR;
                            }
                        }
                    }
                    
                    // Move toward target component
                    if (currentX !== comp2.centerX) {
                        currentX += currentX < comp2.centerX ? 1 : -1;
                    } else if (currentY !== comp2.centerY) {
                        currentY += currentY < comp2.centerY ? 1 : -1;
                    }
                }
            }
            
            // Add connection pads around components
            components.forEach(comp => {
                const padPositions = [
                    { x: comp.x - 1, y: comp.centerY }, // Left pad
                    { x: comp.x + comp.width, y: comp.centerY }, // Right pad
                    { x: comp.centerX, y: comp.y - 1 }, // Top pad
                    { x: comp.centerX, y: comp.y + comp.height } // Bottom pad
                ];
                
                padPositions.forEach(pad => {
                    if (pad.x >= 0 && pad.x < dynamicMapWidth && 
                        pad.y >= 0 && pad.y < dynamicMapHeight) {
                        gameMap[pad.y][pad.x] = TILE_FLOOR;
                    }
                });
            });
        }

        /**
         * Generates a marble-themed map with cathedral-like grand halls
         */
        function generateMarbleMap() {
            initializeMap();
            generatePaths(dynamicMapWidth * dynamicMapHeight * 0.25);
        }

        /**
         * Generates a void-themed map with scattered platforms and teleporter pads
         */
        function generateVoidMap() {
            initializeMap();
            generatePaths(dynamicMapWidth * dynamicMapHeight * 0.25);
        }

        /**
         * Generates the appropriate map based on current world
         */
        function generateWorldMap() {
            const world = getCurrentWorld();
            console.log('generateWorldMap() - Current world:', world ? world.name : 'undefined', 'Using original random walk generator for all worlds');
            
            // Use the original random walk algorithm for all worlds
            initializeMap();
            generatePaths(dynamicMapWidth * dynamicMapHeight * 0.25);
        }

        /**
         * Generates a random integer between min (inclusive) and max (inclusive).
         * @param {number} min - The minimum value.
         * @param {number} max - The maximum value.
         * @returns {number} A random integer.
         */
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /**
         * Generates a random integer between min (inclusive) and max (inclusive),
         * biased by the health ratio of attacker to defender and optionally by attacker's flow.
         * If attacker is stronger, bias towards lower damage.
         * If attacker's weaker, bias towards higher damage.
         * If attacker's flow is high, bias towards higher damage.
         * If attacker's flow is low, bias towards lower damage.
         * @param {number} min - The minimum damage value.
         * @param {number} max - The maximum damage value.
         * @param {number} attackerHealth - Current health of the attacker.
         * @param {number} defenderHealth - Current health of the defender.
         * @param {number} [currentAttackerFlow=null] - Optional: The current flow of the attacker.
         * @returns {number} A biased random integer damage value.
         */
        /**
         * Balanced damage calculation that prevents one-shots and extreme swings
         * @param {number} attackerHealth - Health of the attacking entity
         * @returns {number} Damage dealt (balanced and predictable)
         */
        function calculateSimpleDamage(attackerHealth) {
            if (attackerHealth <= 0) {
                return 0;
            }
            
            // Base damage: square root scaling to reduce extreme high-health advantages
            // This means 100 health ≈ 15 base damage, 25 health ≈ 7.5 base damage
            const baseDamage = Math.sqrt(attackerHealth) * COMBAT_BASE_DAMAGE_MULTIPLIER;
            
            // Add configurable random variation
            const variation = baseDamage * COMBAT_DAMAGE_VARIATION;
            const minDamage = Math.max(COMBAT_MIN_DAMAGE, Math.floor(baseDamage - variation));
            const maxDamage = Math.floor(baseDamage + variation);
            
            // Cap maximum damage to prevent one-shots
            const maxAllowedDamage = Math.min(maxDamage, COMBAT_MAX_DAMAGE_CAP);
            const finalMinDamage = Math.min(minDamage, maxAllowedDamage);
            
            return Math.floor(Math.random() * (maxAllowedDamage - finalMinDamage + 1)) + finalMinDamage;
        }

        /**
         * Calculates the Euclidean distance between two points.
         * @param {object} p1 - First point {x, y}.
         * @param {object} p2 - Second point {x, y}.
         * @returns {number} The distance between the two points.
         */
        function getDistance(p1, p2) {
            if (!p1 || !p2) {
                console.error("Attempted to calculate distance with null or undefined point:", p1, p2);
                return Infinity;
            }
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        /**
         * Optimized helper function to find an empty floor tile with caching
         * @param {Array<object>} excludeEntities - An array of entities to avoid placing the tile on.
         * @returns {object|null} An {x, y} object if a spot is found, otherwise null.
         */
        function findEmptyFloorTile(excludeEntities = []) {
            // Safety check for circular dependency: player position may not be set during initial map generation
            const hasValidPlayerPosition = player && 
                typeof player.x === 'number' && typeof player.y === 'number' && 
                !isNaN(player.x) && !isNaN(player.y);
            
            if (!hasValidPlayerPosition) {
                console.warn("Player position invalid, using fallback tile placement without reachability check");
                let attempts = 0;
                const MAX_FALLBACK_ATTEMPTS = 100; // Reduced for efficiency
                while (attempts < MAX_FALLBACK_ATTEMPTS) {
                    const randX = getRandomInt(0, dynamicMapWidth - 1);
                    const randY = getRandomInt(0, dynamicMapHeight - 1);
                    if (gameMap[randY][randX] === TILE_FLOOR &&
                        !excludeEntities.some(e => e.x === randX && e.y === randY)) {
                        console.log(`Found floor tile at (${randX}, ${randY}) using simple placement (no reachability check)`);
                        return { x: randX, y: randY };
                    }
                    attempts++;
                }
                console.error("Failed to find any floor tile even with simple placement");
                return null;
            }

            // Player position is valid - use full pathfinding for reachability checks
            // Pre-compute exclude positions for faster lookup
            const excludeSet = new Set();
            for (let i = 0; i < excludeEntities.length; i++) {
                const e = excludeEntities[i];
                excludeSet.add(`${e.x},${e.y}`);
            }

            const potentialTiles = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            // Optimized double loop with early exit conditions
            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (gameMap[y][x] === TILE_FLOOR && !excludeSet.has(`${x},${y}`)) {
                        // Quick wall neighbor check
                        let wallNeighbors = 0;
                        for (let i = 0; i < 4; i++) {
                            const dx = directions[i][0];
                            const dy = directions[i][1];
                            const checkX = x + dx;
                            const checkY = y + dy;

                            if (checkX >= 0 && checkX < dynamicMapWidth && checkY >= 0 && checkY < dynamicMapHeight) {
                                if (gameMap[checkY][checkX] === TILE_WALL) {
                                    wallNeighbors++;
                                }
                            } else {
                                wallNeighbors++;
                            }
                        }

                        if (wallNeighbors < 4) {
                            // Cache pathfinding results to avoid repeated calculations
                            const cacheKey = `${player.x},${player.y}-${x},${y}`;
                            let hasPath = pathfindingCache.get(cacheKey);
                            
                            if (hasPath === undefined) {
                                hasPath = findPathBasic(player.x, player.y, x, y, gameMap, dynamicMapWidth, dynamicMapHeight) !== null;
                                pathfindingCache.set(cacheKey, hasPath);
                            }
                            
                            if (hasPath) {
                                potentialTiles.push({ x, y });
                                // Early exit if we have enough options
                                if (potentialTiles.length > 10) {
                                    break;
                                }
                            }
                        }
                    }
                }
                if (potentialTiles.length > 10) break;
            }

            if (potentialTiles.length > 0) {
                const randomIndex = getRandomInt(0, potentialTiles.length - 1);
                return potentialTiles[randomIndex];
            } else {
                console.warn("No reachable empty floor tiles found for placement of item.");
                let attempts = 0;
                const MAX_LAST_RESORT_ATTEMPTS = 100; // Consistent with fallback attempts
                while (attempts < MAX_LAST_RESORT_ATTEMPTS) {
                    const randX = getRandomInt(0, dynamicMapWidth - 1);
                    const randY = getRandomInt(0, dynamicMapHeight - 1);
                    if (gameMap[randY][randX] === TILE_FLOOR && !excludeSet.has(`${randX},${randY}`)) {
                        console.warn(`Placed item at (${randX}, ${randY}) as a last resort (reachability not guaranteed).`);
                        return { x: randX, y: randY };
                    }
                    attempts++;
                }
                console.error("Failed to find any empty floor tile even as a last resort.");
                return null;
            }
        }

        /**
         * Finds the shortest path from start to end using Breadth-First Search (BFS).
         * Returns an array of {x, y} coordinates representing the path, or null if no path exists.
         * @param {number} startX - Starting X coordinate.
         * @param {number} startY - Starting Y coordinate.
         * @param {number} endX - Target X coordinate.
         * @param {number} endY - Target Y coordinate.
         * @param {Array<Array<number>>} map - The game map.
         * @param {number} mapWidth - Width of the map.
         * @param {number} mapHeight - Height of the map.
         * @param {Array<object>} [entitiesToStrictlyAvoid=[]] - Optional: An array of entity positions ({x, y}) to treat as impassable.
         * @returns {Array<{x: number, y: number}>|null} The path as an array of coordinates, or null.
         */
        function findPathBasic(startX, startY, endX, endY, map, mapWidth, mapHeight, entitiesToStrictlyAvoid = []) {
            performanceStats.pathfindingCalls++;
            
            // Generate cache key including entities to avoid
            const avoidKey = entitiesToStrictlyAvoid.map(e => `${e.x},${e.y}`).sort().join('|');
            const cacheKey = `basic_${startX},${startY}_${endX},${endY}_${avoidKey}_${cacheValidationFrame}`;
            
            // Check cache first
            if (pathfindingCache.has(cacheKey)) {
                performanceStats.cacheHits++;
                return pathfindingCache.get(cacheKey);
            }
            
            performanceStats.cacheMisses++;
            logPerformanceStats(); // Check if we should log stats

            const queue = [{ x: startX, y: startY, path: [] }];
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            // Pre-compute entity avoid set for faster lookup
            const avoidSet = new Set();
            for (let i = 0; i < entitiesToStrictlyAvoid.length; i++) {
                const e = entitiesToStrictlyAvoid[i];
                avoidSet.add(`${e.x},${e.y}`);
            }

            while (queue.length > 0) {
                const { x, y, path } = queue.shift();

                if (x === endX && y === endY) {
                    const result = path.concat({ x, y });
                    pathfindingCache.set(cacheKey, result);
                    cleanupPathfindingCache(); // Prevent memory leak
                    return result;
                }

                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    const posKey = `${newX},${newY}`;

                    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS) &&
                        !visited.has(posKey) &&
                        !avoidSet.has(posKey)) {

                        visited.add(posKey);
                        queue.push({ x: newX, y: newY, path: path.concat({ x, y }) });
                    }
                }
            }
            
            pathfindingCache.set(cacheKey, null);
            cleanupPathfindingCache(); // Prevent memory leak
            return null;
        }

        /**
         * Finds the shortest path from start to end using a Dijkstra-like algorithm,
         * with a penalty for moving into tiles adjacent to enemies.
         * @param {number} startX - Starting X coordinate.
         * @param {number} startY - Starting Y coordinate.
         * @param {number} endX - Target X coordinate.
         * @param {number} endY - Target Y coordinate.
         * @param {Array<Array<number>>} map - The game map.
         * @param {number} mapWidth - Width of the map.
         * @param {number} mapHeight - Height of the map.
         * @param {Array<object>} entitiesWithProximityPenalty - An array of entity positions ({x, y}) to apply proximity penalty for.
         * @returns {Array<{x: number, y: number}>|null} The path as an array of coordinates, or null.
         */
        function findPathWithProximityPenalty(startX, startY, endX, endY, map, mapWidth, mapHeight, entitiesWithProximityPenalty) {
            performanceStats.pathfindingCalls++;
            
            // Generate cache key
            const entitiesKey = entitiesWithProximityPenalty.map(e => `${e.x},${e.y}`).sort().join('|');
            const cacheKey = `proximity_${startX},${startY}_${endX},${endY}_${entitiesKey}_${cacheValidationFrame}`;
            
            // Check cache first
            if (pathfindingCache.has(cacheKey)) {
                performanceStats.cacheHits++;
                return pathfindingCache.get(cacheKey);
            }
            
            performanceStats.cacheMisses++;

            const queue = [{ x: startX, y: startY, path: [], cost: 0 }];
            const visitedCosts = new Map();
            visitedCosts.set(`${startX},${startY}`, 0);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Only cardinal directions for pathfinding
            const eightDirections = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]; // For proximity check

            const PROXIMITY_PENALTY = 5; // Cost penalty for moving into a tile adjacent to an entity

            // Pre-compute entity positions for faster lookup
            const entitySet = new Set();
            for (let i = 0; i < entitiesWithProximityPenalty.length; i++) {
                const e = entitiesWithProximityPenalty[i];
                entitySet.add(`${e.x},${e.y}`);
            }

            while (queue.length > 0) {
                queue.sort((a, b) => a.cost - b.cost);
                const { x, y, path, cost } = queue.shift();

                if (cost > visitedCosts.get(`${x},${y}`)) {
                    continue;
                }

                if (x === endX && y === endY) {
                    const result = path.concat({ x, y });
                    pathfindingCache.set(cacheKey, result);
                    cleanupPathfindingCache(); // Prevent memory leak
                    return result;
                }

                for (const [dx, dy] of directions) { // Iterate over cardinal directions for movement
                    const newX = x + dx;
                    const newY = y + dy;

                    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS)) {

                        let stepCost = 1;

                        // Optimized proximity check using Set
                        for (let i = 0; i < 8; i++) { // Check proximity in all 8 directions
                            const edx = eightDirections[i][0];
                            const edy = eightDirections[i][1];
                            const checkX = newX + edx;
                            const checkY = newY + edy;
                            if (entitySet.has(`${checkX},${checkY}`)) {
                                stepCost += PROXIMITY_PENALTY;
                                break;
                            }
                        }

                        const newCost = cost + stepCost;

                        if (!visitedCosts.has(`${newX},${newY}`) || newCost < visitedCosts.get(`${newX},${newY}`)) {
                            visitedCosts.set(`${newX},${newY}`, newCost);
                            queue.push({ x: newX, y: newY, path: path.concat({ x, y }), cost: newCost });
                        }
                    }
                }
            }
            
            pathfindingCache.set(cacheKey, null);
            cleanupPathfindingCache(); // Prevent memory leak
            return null;
        }

        /**
         * Clean up pathfinding cache when it grows too large to prevent memory leaks.
         * Removes oldest entries (by insertion order) when cache exceeds size limit.
         */
        function cleanupPathfindingCache() {
            if (pathfindingCache.size > MAX_PATHFINDING_CACHE_SIZE) {
                // Remove oldest 20% of entries
                const keysToDelete = Array.from(pathfindingCache.keys()).slice(0, Math.floor(MAX_PATHFINDING_CACHE_SIZE * 0.2));
                keysToDelete.forEach(key => pathfindingCache.delete(key));
                console.log(`Pathfinding cache cleaned: removed ${keysToDelete.length} entries, size now ${pathfindingCache.size}`);
            }
        }



        /**
         * Finds a random floor tile for the player's starting position, prioritizing the top-left corner.
         */
        function findPlayerStartInCorner() {
            const playerPos = findEmptyFloorTile([]);
            if (playerPos) {
                player.x = playerPos.x;
                player.y = playerPos.y; // Corrected: assign to player.y
            } else {
                console.error("Failed to find a valid player start position. Forcing placement.");
                player.x = 1;
                player.y = 1;
                if (gameMap[1] && gameMap[1][1] === TILE_WALL) {
                    gameMap[1][1] = TILE_FLOOR; // This is the key part
                }
            }
        }

        /**
         * Checks if all floor tiles are reachable from a starting position, treating stairs as passable
         * @param {number} startX - Starting X coordinate
         * @param {number} startY - Starting Y coordinate
         * @param {Array<Array<number>>} map - The game map
         * @returns {boolean} True if all floor tiles are reachable
         */
        function checkConnectivity(startX, startY, map) {
            const visited = new Set();
            const queue = [{ x: startX, y: startY }];
            visited.add(`${startX},${startY}`);
            
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            let reachableFloorTiles = 0;
            let totalFloorTiles = 0;
            
            // Optimized floor tile counting with early exit potential
            const floorTilePositions = [];
            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (map[y][x] === TILE_FLOOR || map[y][x] === TILE_STAIRS) {
                        totalFloorTiles++;
                        floorTilePositions.push({ x, y });
                    }
                }
            }
            
            // Quick exit for small maps
            if (totalFloorTiles <= 1) {
                return true;
            }
            
            // BFS to find all reachable tiles with optimizations
            while (queue.length > 0) {
                const { x, y } = queue.shift();
                
                if (map[y][x] === TILE_FLOOR || map[y][x] === TILE_STAIRS) {
                    reachableFloorTiles++;
                    // Early exit if we've reached all floor tiles
                    if (reachableFloorTiles === totalFloorTiles) {
                        return true;
                    }
                }
                
                // Optimized direction checking
                for (let i = 0; i < 4; i++) {
                    const dx = directions[i][0];
                    const dy = directions[i][1];
                    const newX = x + dx;
                    const newY = y + dy;
                    const posKey = `${newX},${newY}`;
                    
                    if (newX >= 0 && newX < dynamicMapWidth && newY >= 0 && newY < dynamicMapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS) &&
                        !visited.has(posKey)) {
                        
                        visited.add(posKey);
                        queue.push({ x: newX, y: newY });
                    }
                }
            }
            
            return reachableFloorTiles === totalFloorTiles;
        }

        /**
         * Count how many tiles are reachable from a starting position using BFS.
         * Used to detect if stairs placement creates unreachable map sections.
         */
        function countReachableTiles(map, mapWidth, mapHeight, startX, startY, enemiesToAvoid = []) {
            const queue = [{ x: startX, y: startY }];
            const visited = new Set();
            visited.add(`${startX},${startY}`);
            let reachableCount = 0;
            let reachablePositions = [];
            
            // Create set of enemy positions for fast lookup
            const enemyPositions = new Set();
            for (const enemy of enemiesToAvoid) {
                enemyPositions.add(`${enemy.x},${enemy.y}`);
            }
            
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            
            while (queue.length > 0) {
                const { x, y } = queue.shift();
                
                // Count all floor tiles and stairs as reachable
                if (map[y][x] === TILE_FLOOR || map[y][x] === TILE_STAIRS) {
                    reachableCount++;
                    reachablePositions.push(`(${x},${y})`);
                }
                
                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    const posKey = `${newX},${newY}`;
                    
                    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight &&
                        (map[newY][newX] === TILE_FLOOR || map[newY][newX] === TILE_STAIRS) &&
                        !visited.has(posKey) &&
                        !enemyPositions.has(posKey)) { // Don't pathfind through enemies
                        
                        visited.add(posKey);
                        queue.push({ x: newX, y: newY });
                    }
                }
            }
            
            // Console log removed for performance
            return reachableCount;
        }

        /**
         * Count total floor and stairs tiles in the map.
         * Used for comparison with reachable tile count.
         */
        function countTotalFloorAndStairs(map, mapWidth, mapHeight) {
            let total = 0;
            let floorCount = 0;
            let stairsCount = 0;
            let allPositions = [];
            
            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (map[y][x] === TILE_FLOOR) {
                        floorCount++;
                        total++;
                        allPositions.push(`(${x},${y})`);
                    } else if (map[y][x] === TILE_STAIRS) {
                        stairsCount++;
                        total++;
                        allPositions.push(`(${x},${y})S`);
                    }
                }
            }
            // Debug logs removed for performance
            return total;
        }

        /**
         * Finds a random floor tile in the bottom-right corner for the staircase, prioritizing open areas.
         */
        function placeStairsOppositeCorner() {
            // Debug output reduced for performance
            let found = false;
            let attempts = 0;
            const MAX_PLACEMENT_ATTEMPTS = 1000;
            const MIN_OPEN_NEIGHBORS_FOR_STAIRS = 2; // Minimum number of adjacent floor tiles for stairs

            const searchStartX = Math.floor(dynamicMapWidth * 3 / 4);
            const searchStartY = Math.floor(dynamicMapHeight * 3 / 4);

            let validStairsCandidates = [];
            const cardinalDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            // First, try to find candidates with enough open neighbors that don't break connectivity
            for (let y = searchStartY; y < dynamicMapHeight; y++) {
                for (let x = searchStartX; x < dynamicMapWidth; x++) {
                    if (y >= 0 && y < dynamicMapHeight && x >= 0 && x < dynamicMapWidth &&
                        gameMap[y][x] === TILE_FLOOR && (x !== player.x || y !== player.y)) {

                        let openNeighbors = 0;
                        for (const [dx, dy] of cardinalDirections) {
                            const checkX = x + dx;
                            const checkY = y + dy;
                            if (checkX >= 0 && checkX < dynamicMapWidth && checkY >= 0 && checkY < dynamicMapHeight &&
                                gameMap[checkY][checkX] === TILE_FLOOR) {
                                openNeighbors++;
                            }
                        }

                        if (openNeighbors >= MIN_OPEN_NEIGHBORS_FOR_STAIRS) {
                            // Test placing stairs here and check if connectivity is maintained
                            const originalTile = gameMap[y][x];
                            gameMap[y][x] = TILE_STAIRS;
                            
                            if (checkConnectivity(player.x, player.y, gameMap)) {
                                validStairsCandidates.push({ x, y, openNeighbors });
                            }
                            
                            // Restore original tile
                            gameMap[y][x] = originalTile;
                        }
                    }
                }
            }

            // Sort candidates by openNeighbors in descending order
            validStairsCandidates.sort((a, b) => b.openNeighbors - a.openNeighbors);

            if (validStairsCandidates.length > 0) {
                // Pick candidates and validate connectivity until we find one that doesn't create chokepoints
                const bestCandidatesSlice = validStairsCandidates.slice(0, Math.min(5, validStairsCandidates.length));
                // Debug output reduced for performance
                
                for (let i = 0; i < bestCandidatesSlice.length && !found; i++) {
                    const chosen = bestCandidatesSlice[i];
                    const originalTile = gameMap[chosen.y][chosen.x];
                    gameMap[chosen.y][chosen.x] = TILE_STAIRS;
                    
                    // TEMPORARY: Skip basic connectivity check, only test chokepoint detection
                    const reachableCount = countReachableTiles(gameMap, dynamicMapWidth, dynamicMapHeight, player.x, player.y);
                    const totalFloorTiles = countTotalFloorAndStairs(gameMap, dynamicMapWidth, dynamicMapHeight);
                    
                    console.log(`CHOKEPOINT TEST: ${reachableCount}/${totalFloorTiles} tiles reachable from (${player.x},${player.y}) with stairs at (${chosen.x},${chosen.y})`);
                    
                    let fullReachability = true;
                    if (reachableCount < totalFloorTiles) {
                        fullReachability = false;
                        console.log(`PRIMARY STAIRS REJECTED: Creates unreachable areas (${totalFloorTiles - reachableCount} tiles unreachable)`);
                    } else {
                        console.log(`Primary stairs candidate OK - all ${totalFloorTiles} tiles reachable`);
                    }
                    
                    // Always accept for now to test detection
                    if (true) {
                        stairs.x = chosen.x;
                        stairs.y = chosen.y;
                        found = true;
                        console.log(`Primary stairs placed at (${chosen.x}, ${chosen.y}) with full connectivity`);
                    } else {
                        // Revert and try next candidate
                        gameMap[chosen.y][chosen.x] = originalTile;
                    }
                }
            }

            // Fallback if no suitable candidates found with open neighbors - check connectivity for any valid position
            if (!found) {
                // Falling back to random placement
                attempts = 0;
                while (!found && attempts < MAX_PLACEMENT_ATTEMPTS) {
                    const randX = searchStartX + Math.floor(Math.random() * (dynamicMapWidth - searchStartX));
                    const randY = searchStartY + Math.floor(Math.random() * (dynamicMapHeight - searchStartY));

                    if (randY >= 0 && randY < dynamicMapHeight && randX >= 0 && randX < dynamicMapWidth &&
                        gameMap[randY][randX] === TILE_FLOOR && (randX !== player.x || randY !== player.y)) {
                        
                        // Test connectivity before placing stairs
                        const originalTile = gameMap[randY][randX];
                        gameMap[randY][randX] = TILE_STAIRS;
                        
                        // Check both basic connectivity AND full map reachability
                        const basicConnectivity = checkConnectivity(player.x, player.y, gameMap);
                        let fullReachability = true;
                        
                        if (basicConnectivity) {
                            // Additional check: ensure all floor tiles remain reachable from player
                            const reachableCount = countReachableTiles(gameMap, dynamicMapWidth, dynamicMapHeight, player.x, player.y);
                            const totalFloorTiles = countTotalFloorAndStairs(gameMap, dynamicMapWidth, dynamicMapHeight);
                            
                            console.log(`Fallback chokepoint check: ${reachableCount}/${totalFloorTiles} tiles reachable from (${player.x},${player.y}) with stairs at (${randX},${randY})`);
                            
                            if (reachableCount < totalFloorTiles) {
                                fullReachability = false;
                                console.log(`FALLBACK STAIRS REJECTED: Creates unreachable areas`);
                            } else {
                                console.log(`Fallback stairs candidate OK - no chokepoints detected`);
                            }
                        }
                        
                        if (basicConnectivity && fullReachability) {
                            stairs.x = randX;
                            stairs.y = randY;
                            found = true;
                        } else {
                            // Restore original tile if connectivity fails
                            gameMap[randY][randX] = originalTile;
                        }
                    }
                    attempts++;
                }
            }

            // Final fallback if still not found (should be rare with MAX_PLACEMENT_ATTEMPTS)
            if (!found) {
                attempts = 0;
                while (!found && attempts < MAX_PLACEMENT_ATTEMPTS) {
                    const randX = Math.floor(Math.random() * dynamicMapWidth);
                    const randY = Math.floor(Math.random() * dynamicMapHeight);
                    if (gameMap[randY][randX] === TILE_FLOOR && (randX !== player.x || randY !== player.y)) {
                        
                        // Test connectivity before placing stairs
                        const originalTile = gameMap[randY][randX];
                        console.log(`Final fallback: Testing stairs at (${randX},${randY}): original tile = ${originalTile}`);
                        gameMap[randY][randX] = TILE_STAIRS;
                        console.log(`Final fallback: Stairs temporarily placed: gameMap[${randY}][${randX}] = ${gameMap[randY][randX]}`);
                        
                        // Check both basic connectivity AND full map reachability
                        const basicConnectivity = checkConnectivity(player.x, player.y, gameMap);
                        let fullReachability = true;
                        
                        if (basicConnectivity) {
                            const reachableCount = countReachableTiles(gameMap, dynamicMapWidth, dynamicMapHeight, player.x, player.y);
                            const totalFloorTiles = countTotalFloorAndStairs(gameMap, dynamicMapWidth, dynamicMapHeight);
                            
                            console.log(`Final fallback chokepoint check: ${reachableCount}/${totalFloorTiles} tiles reachable from (${player.x},${player.y}) with stairs at (${randX},${randY})`);
                            
                            if (reachableCount < totalFloorTiles) {
                                fullReachability = false;
                                console.log(`FINAL FALLBACK STAIRS REJECTED: Creates unreachable areas`);
                            } else {
                                console.log(`Final fallback stairs candidate OK - no chokepoints detected`);
                            }
                        }
                        
                        if (basicConnectivity && fullReachability) {
                            stairs.x = randX;
                            stairs.y = randY;
                            found = true;
                        } else {
                            // Restore original tile if connectivity fails
                            gameMap[randY][randX] = originalTile;
                        }
                    }
                    attempts++;
                }
            }

            if (!found) {
                console.error("Failed to find a valid stairs position after many attempts. Forcing placement.");
                stairs.x = dynamicMapWidth - 2;
                stairs.y = dynamicMapHeight - 2;
                if (gameMap[dynamicMapHeight - 2] && gameMap[dynamicMapHeight - 2][dynamicMapWidth - 2] === TILE_WALL) {
                    gameMap[dynamicMapHeight - 2][dynamicMapWidth - 2] = TILE_FLOOR;
                }
                gameMap[stairs.y][stairs.x] = TILE_STAIRS;
            }
        }

        function placeKey() {
            let found = false;
            let attempts = 0;
            const MAX_PLACEMENT_ATTEMPTS = 1000;

            while (!found && attempts < MAX_PLACEMENT_ATTEMPTS) {
                const randX = Math.floor(Math.random() * dynamicMapWidth);
                const randY = Math.floor(Math.random() * dynamicMapHeight);

                // Place key on floor tiles, but not on player, stairs, or enemy positions
                if (gameMap[randY][randX] === TILE_FLOOR && 
                    (randX !== player.x || randY !== player.y) && 
                    (randX !== stairs.x || randY !== stairs.y)) {
                    
                    // Check if any enemy is on this position
                    let enemyOnTile = false;
                    for (let enemy of enemies) {
                        if (enemy.x === randX && enemy.y === randY) {
                            enemyOnTile = true;
                            break;
                        }
                    }

                    if (!enemyOnTile) {
                        key.x = randX;
                        key.y = randY;
                        key.collected = false;
                        found = true;
                        console.log(`Key placed at (${randX}, ${randY})`);
                        
                        // Double-check: if any enemy somehow ended up on the key position, move them away
                        enemies.forEach(enemy => {
                            if (enemy.x === key.x && enemy.y === key.y) {
                                console.log(`Moving enemy away from key position (${key.x}, ${key.y})`);
                                // Find a new position for this enemy
                                const newPos = findEmptyFloorTile([player, stairs, key, ...enemies.filter(e => e !== enemy)]);
                                if (newPos) {
                                    enemy.x = newPos.x;
                                    enemy.y = newPos.y;
                                    console.log(`Enemy moved to (${newPos.x}, ${newPos.y})`);
                                }
                            }
                        });
                    }
                }
                attempts++;
            }

            if (!found) {
                console.error("Failed to find a valid key position after many attempts. Forcing placement.");
                // Find any available floor tile
                for (let y = 0; y < dynamicMapHeight; y++) {
                    for (let x = 0; x < dynamicMapWidth; x++) {
                        if (gameMap[y][x] === TILE_FLOOR && 
                            (x !== player.x || y !== player.y) && 
                            (x !== stairs.x || y !== stairs.y)) {
                            key.x = x;
                            key.y = y;
                            key.collected = false;
                            found = true;
                            break;
                        }
                    }
                    if (found) break;
                }
            }
        }

        /**
         * Spawns enemies on the map, distributing total health points equal to the current level.
         * @param {number} levelHealthBonus - Additional health points for enemies based on player's health.
         * @param {number} playerAverageFlow - The player's average flow so far in the run.
         */
        function spawnEnemies(levelHealthBonus = 0, playerAverageFlow = 0) {
            enemies = [];
            const totalHealthForLevel = currentLevel + levelHealthBonus;

            let actualNumEnemies;
            if (currentLevel === 1) {
                actualNumEnemies = 1; // For level 1, always spawn exactly one enemy
            } else {
                const maxPossibleEnemies = Math.max(1, Math.min(totalHealthForLevel, 7));
                actualNumEnemies = getRandomInt(1, maxPossibleEnemies);
            }

            // Removed: Reintroduced minimum enemies based on level number divided by two
            // actualNumEnemies = Math.max(Math.floor(currentLevel / 2), actualNumEnemies);


            let remainingHealthToDistribute = totalHealthForLevel;

            for (let i = 0; i < actualNumEnemies; i++) {
                const excludeList = [player, stairs, ...enemies]; // Ensure stairs is in the exclude list for spawning
                
                // Also exclude remote control if it exists and hasn't been collected
                if (key && !key.collected) {
                    excludeList.push(key);
                }
                
                const enemyPos = findEmptyFloorTile(excludeList);

                if (enemyPos) {
                    // For very small maps (4x4 or smaller), skip chokepoint validation entirely
                    // as it's nearly impossible to avoid chokepoints on such small spaces
                    const isVerySmallMap = dynamicMapWidth <= 4 && dynamicMapHeight <= 4;
                    
                    if (!isVerySmallMap) {
                        // Only do chokepoint checking on larger maps
                        const reachableWithEnemy = countReachableTiles(gameMap, dynamicMapWidth, dynamicMapHeight, player.x, player.y, [...enemies, enemyPos]);
                        const totalFloorTiles = countTotalFloorAndStairs(gameMap, dynamicMapWidth, dynamicMapHeight);
                        
                        // Allow up to 1 unreachable tile as acceptable (less strict)
                        if (reachableWithEnemy < totalFloorTiles - 1) {
                            console.log(`Enemy position would create major chokepoint - trying once more`);
                            // Try one more position before giving up
                            const alternativePos = findEmptyFloorTile([player, stairs, ...enemies, enemyPos]);
                            if (alternativePos) {
                                const altReachable = countReachableTiles(gameMap, dynamicMapWidth, dynamicMapHeight, player.x, player.y, [...enemies, alternativePos]);
                                if (altReachable >= totalFloorTiles - 1) {
                                    enemyPos.x = alternativePos.x;
                                    enemyPos.y = alternativePos.y;
                                }
                            }
                            // If alternative doesn't work, still place the enemy - better than no enemy
                        }
                    }
                    
                    let role;
                    const roleRoll = Math.random();
                    if (roleRoll < 0.4) {
                        role = 'hunter';
                    } else if (roleRoll < 0.7) {
                        role = 'guard';
                    } else {
                        role = 'tracker';
                    }

                    // Temporary health for initial flow calculation (will be updated after distribution)
                    const tempEnemyHealth = 1;

                    // Calculate initial enemy flow based on player's average flow and inverse health bias
                    let initialEnemyFlowForThisEnemy = 0;
                    if (playerAverageFlow > 0) {
                        const healthNormalized = tempEnemyHealth / ENEMY_VISUAL_HEALTH_THRESHOLD;
                        // Bias the random factor: lower healthNormalized (lower health) means randomFactor biases towards 0
                        // Higher healthNormalized (higher health) means randomFactor biases towards 1
                        let effectiveRandomFactor = Math.random() * healthNormalized;
                        initialEnemyFlowForThisEnemy = playerAverageFlow * effectiveRandomFactor;
                    }

                    const baseStepsForFlow = 5; // Use a base number of steps to avoid very high flow from 1 damage / 1 step
                    const initialEnemyDamageDealt = initialEnemyFlowForThisEnemy * baseStepsForFlow;
                    const initialEnemyStepsTaken = initialEnemyFlowForThisEnemy > 0 ? baseStepsForFlow : 0;

                    const enemyName = generateAgentName();
                    enemies.push({
                        x: enemyPos.x, y: enemyPos.y, role: role, health: tempEnemyHealth,
                        name: enemyName,
                        thrustAnimActive: false, thrustAnimStartTime: 0, thrustAnimDuration: 150,
                        thrustAnimDirectionX: 0, thrustAnimDirectionY: 0, thrustAnimMagnitude: 0,
                        totalDamageDealtByThisEnemy: initialEnemyDamageDealt,
                        stepsTakenByThisEnemy: initialEnemyStepsTaken,
                        flowLevel: initialEnemyFlowForThisEnemy,
                        initialHealth: tempEnemyHealth,
                        totalDamageTakenByThisEnemy: 0
                    });
                    remainingHealthToDistribute--;
                } else {
                    console.warn(`Could not place enemy ${i + 1}. Skipping this enemy.`);
                }
            }

            // Distribute remaining health points among spawned enemies
            while (remainingHealthToDistribute > 0 && enemies.length > 0) {
                const randomIndex = getRandomInt(0, enemies.length - 1);
                enemies[randomIndex].health = enemies[randomIndex].health + 1; // Explicit assignment
                // Update initialHealth here as well, because we're still in the "initialization" phase for this enemy
                enemies[randomIndex].initialHealth = enemies[randomIndex].health;
                remainingHealthToDistribute--;
            }

            // After health distribution, re-calculate flow based on final enemy health
            enemies.forEach(enemy => {
                let finalEnemyFlowForThisEnemy = 0;
                if (playerAverageFlow > 0) {
                    const healthNormalized = enemy.health / ENEMY_VISUAL_HEALTH_THRESHOLD;
                    // Bias the random factor: lower healthNormalized (lower health) means randomFactor biases towards 0
                    // Higher healthNormalized (higher health) means randomFactor biases towards 1
                    let effectiveRandomFactor = Math.random() * healthNormalized;
                    finalEnemyFlowForThisEnemy = playerAverageFlow * effectiveRandomFactor;
                }
                const baseStepsForFlow = 5;
                enemy.totalDamageDealtByThisEnemy = finalEnemyFlowForThisEnemy * baseStepsForFlow;
                enemy.stepsTakenByThisEnemy = finalEnemyFlowForThisEnemy > 0 ? baseStepsForFlow : 0;
                enemy.flowLevel = finalEnemyFlowForThisEnemy; // Update flowLevel with final calculated value
            });


            // Fallback to ensure at least one enemy if somehow none were placed and totalHealthForLevel > 0
            if (totalHealthForLevel > 0 && enemies.length === 0) {
                const enemyPos = findEmptyFloorTile([player, stairs]); // Ensure stairs is excluded even in fallback
                if (enemyPos) {
                    const baseStepsForFlow = 5;
                    const initialEnemyDamageDealt = playerAverageFlow * baseStepsForFlow; // Use player flow as fallback
                    const initialEnemyStepsTaken = playerAverageFlow > 0 ? baseStepsForFlow : 0;
                    enemies.push({
                        x: enemyPos.x, y: enemyPos.y, role: 'hunter', health: totalHealthForLevel,
                        thrustAnimActive: false, thrustAnimStartTime: 0, thrustAnimDirectionX: 0, thrustAnimDirectionY: 0, thrustAnimMagnitude: 0,
                        totalDamageDealtByThisEnemy: initialEnemyDamageDealt, stepsTakenByThisEnemy: initialEnemyStepsTaken,
                        flowLevel: playerAverageFlow, // Fallback flow level
                        initialHealth: totalHealthForLevel, // Fallback initial health
                        totalDamageTakenByThisEnemy: 0 // Initialize for new enemy flow logic
                    });
                } else {
                    console.error("Critical: Could not place any enemies even for fallback!");
                }
            }
        }

        /**
         * Spawns scattered health pickups on the map.
         */
        function spawnPickups() {
            // Filter out previous level's static pickups, keep only enemy drops (if any are left uncollected)
            staticDamageNumbers = staticDamageNumbers.filter(item => item.isEnemyDrop);

            let pointsToDistribute = currentLevel;
            let numPickupsToSpawn = 0;

            if (currentLevel === 1) {
                numPickupsToSpawn = 1; // For level 1, always spawn exactly one pickup
            } else {
                // For other levels, distribute points among multiple pickups as before
                // This logic can be refined if you want a specific number of pickups per level
                // For now, it will try to create pickups with values up to currentLevel,
                // resulting in a variable number of pickups.
                numPickupsToSpawn = currentLevel; // A rough estimate, actual number depends on random values
            }

            for (let i = 0; i < numPickupsToSpawn && pointsToDistribute > 0; i++) {
                const excludeList = [player, stairs, ...enemies, ...staticDamageNumbers.map(s => ({x: s.x, y: s.y}))];
                const pickupPos = findEmptyFloorTile(excludeList);

                if (pickupPos) {
                    let pickupValue;
                    if (currentLevel === 1) {
                        pickupValue = pointsToDistribute; // For level 1, the single pickup gets all points
                    } else {
                        // Determine the maximum value for the current pickup.
                        // It should be at least 1, not more than the remaining points.
                        const maxPickupValue = pointsToDistribute;
                        pickupValue = getRandomInt(1, maxPickupValue);
                    }
                    
                    staticDamageNumbers.push({
                        x: pickupPos.x,
                        y: pickupPos.y,
                        parts: [{ content: { type: 'number', value: pickupValue }, offsetX: 0, offsetY: 0 }],
                        isEnemyDrop: false // Mark as a static pickup
                    });
                    pointsToDistribute = pointsToDistribute - pickupValue; // Explicit assignment
                } else {
                    console.warn(`Could not place a pickup with ${pointsToDistribute} points. Remaining: ${pointsToDistribute}.`);
                    break; // Stop if no more spots can be found
                }
            }
        }

        /**
         * Draws an off-screen indicator for an entity.
         * @param {object} entity - The entity ({x, y}) to draw an indicator for.
         * @param {string} color - The color of the indicator.
         * @param {number} offsetX - The camera's X offset.
         * @param {number} offsetY - The camera's Y offset.
         * @param {number} opacity - The opacity of the indicator.
         */
        function drawOffScreenIndicator(entity, color, offsetX, offsetY, opacity) {
            const minIndicatorSize = dynamicTileSize * 0.3;
            const maxIndicatorSize = dynamicTileSize;

            const entityPixelX = entity.x * dynamicTileSize + offsetX;
            const entityPixelY = entity.y * dynamicTileSize + offsetY;

            const distFromLeft = Math.max(0, -entityPixelX);
            const distFromRight = Math.max(0, entityPixelX - gameCanvas.width); // Distance entity extends beyond right edge
            const distFromTop = Math.max(0, -entityPixelY);
            const distFromBottom = Math.max(0, entityPixelY - gameCanvas.height); // Distance entity extends beyond bottom edge

            const distanceOffScreen = Math.max(distFromLeft, distFromRight, distFromTop, distFromBottom);

            const maxScalingDistance = Math.max(gameCanvas.width, gameCanvas.height) / 3; // Use gameCanvas.width/height

            const normalizedDistance = Math.min(distanceOffScreen / maxScalingDistance, 1);

            const currentIndicatorSize = maxIndicatorSize - (normalizedDistance * (maxScalingDistance - minIndicatorSize));

            let indicatorX, indicatorY;

            if (entityPixelX < 0) {
                indicatorX = 0;
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width) { // Use gameCanvas.width
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
            } else {
                indicatorX = entityPixelX + (dynamicTileSize / 2) - (currentIndicatorSize / 2);
            }

            if (entityPixelY < 0) {
                indicatorY = 0;
            } else if (entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else {
                indicatorY = entityPixelY + (dynamicTileSize / 2) - (currentIndicatorSize / 2);
            }

            if (entityPixelX < 0 && entityPixelY < 0) {
                indicatorX = 0;
                indicatorY = 0;
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width && entityPixelY < 0) { // Use gameCanvas.width
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
                indicatorY = 0;
            } else if (entityPixelX < 0 && entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorX = 0;
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else if (entityPixelX + dynamicTileSize > gameCanvas.width && entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.width/height
                indicatorX = gameCanvas.width - currentIndicatorSize; // Use gameCanvas.width
                indicatorY = gameCanvas.height - currentIndicatorSize; // Use gameCanvas.height
            } else if (entityPixelX < 0 || entityPixelX + dynamicTileSize > gameCanvas.width) { // Use gameCanvas.width
                indicatorY = Math.max(0, Math.min(gameCanvas.height - currentIndicatorSize, indicatorY)); // Use gameCanvas.height
            } else if (entityPixelY < 0 || entityPixelY + dynamicTileSize > gameCanvas.height) { // Use gameCanvas.height
                indicatorX = Math.max(0, Math.min(gameCanvas.width - currentIndicatorSize, indicatorX)); // Use gameCanvas.width
            }

            ctx.save();
            ctx.globalAlpha = opacity; // Apply opacity to the indicator
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(indicatorX), Math.floor(indicatorY), Math.floor(currentIndicatorSize), Math.floor(currentIndicatorSize));
            ctx.restore();
        }

        // Add a roundRect method to CanvasRenderingContext2D for drawing rounded rectangles
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
            if (width < 2 * radius) radius = width / 2;
            if (height < 2 * radius) radius = height / 2;
            this.beginPath();
            this.moveTo(x + radius, y);
            this.arcTo(x + width, y, x + width, y + height, radius);
            this.arcTo(x + width, y + height, x, y + height, radius);
            this.arcTo(x, y + height, x, y, radius);
            this.arcTo(x, y, x + width, y, radius);
            this.closePath();
            return this;
        };

        /**
         * Draws the game map, stairs, player, and enemies on the canvas with a camera effect.
         */
        function drawGame() {
            try {
                const now = performance.now();
                // Early validation
                if (!ctx || !gameCanvas) {
                    console.error('Canvas or context not initialized');
                    return;
                }

                // Clear the canvas with a black background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

                // Validate critical game state
                if (!gameMap || !gameMap.length || !gameMap[0] || !gameMap[0].length) {
                    console.error("Game map is invalid or empty");
                    return;
                }

                // Validate player object exists
                if (!player) {
                    console.error("Player object not initialized");
                    return;
                }

                // Validate player position before drawing
                if (isNaN(player.x) || isNaN(player.y) || player.x === null || player.y === null) {
                    console.error("Player position is invalid. Stopping drawGame.");
                    return;
                }

                // Validate currentLevel is defined
                if (typeof currentLevel === 'undefined' || currentLevel === null) {
                    console.error("currentLevel is not defined");
                    return;
                }

                // ...existing code...

                let currentRenderTileSize;
                let currentRenderOffsetX;
                let currentRenderOffsetY;

                // Calculate the target dynamicTileSize for the current level based on current canvas dimensions
                const targetDynamicTileSizeForLevel = (() => {
                    const initialMaxTileSize = Math.floor(Math.min(gameCanvas.width / MAX_VISIBLE_TILES_LEVEL1, gameCanvas.height / MAX_VISIBLE_TILES_LEVEL1));
                    const finalMinTileSize = Math.floor(Math.min(gameCanvas.width / MIN_VISIBLE_TILES_MAX_LEVEL, gameCanvas.height / MIN_VISIBLE_TILES_MAX_LEVEL));
                    let calculated = initialMaxTileSize - ((Math.min(currentLevel, ZOOM_LEVELS_EFFECTIVE) - 1) * (initialMaxTileSize - finalMinTileSize) / (ZOOM_LEVELS_EFFECTIVE - 1));
                    return Math.max(finalMinTileSize, Math.floor(calculated));
                })();


                if (deathAnimationActive) {
                    const elapsed = now - deathAnimationStartTime;
                    const zoomProgress = Math.min(1, elapsed / DEATH_ZOOM_DURATION);

                    // For death zoom, we zoom *into* the current dynamicTileSize
                    currentRenderTileSize = Math.floor(targetDynamicTileSizeForLevel + (targetDynamicTileSizeForLevel * DEATH_ZOOM_TARGET_TILE_SCALE - targetDynamicTileSizeForLevel) * zoomProgress);

                    // Clamp currentRenderTileSize to prevent it from getting too large or small
                    currentRenderTileSize = Math.max(1, currentRenderTileSize); // Ensure it's at least 1 pixel

                    const targetPlayerCenterScreenX = gameCanvas.width / 2; // Use dynamic canvas width
                    const targetPlayerCenterScreenY = gameCanvas.height / 2; // Use dynamic canvas height

                    currentRenderOffsetX = Math.floor(targetPlayerCenterScreenX - (player.x * currentRenderTileSize + currentRenderTileSize / 2));
                    currentRenderOffsetY = Math.floor(targetPlayerCenterScreenY - (player.y * currentRenderTileSize + currentRenderTileSize / 2));

                    // Remove camera clamping to allow viewing beyond map boundaries during death animation
                    // const totalMapPixelWidthZoomed = dynamicMapWidth * currentRenderTileSize;
                    // const totalMapPixelHeightZoomed = dynamicMapHeight * currentRenderTileSize;
                    // currentRenderOffsetX = Math.max(gameCanvas.width - totalMapPixelWidthZoomed, Math.min(0, currentRenderOffsetX));
                    // currentRenderOffsetY = Math.max(gameCanvas.height - totalMapPixelHeightZoomed, Math.min(0, currentRenderOffsetY));

                } else if (gameStartZoomActive) {
                    const elapsed = now - gameStartZoomStartTime;
                    // Make zoom faster and smooth, slowing at the end (ease-out cubic)
                    const rawProgress = Math.min(1, elapsed / (GAME_START_ZOOM_OUT_DURATION * 0.6)); // 40% faster overall
                    // Ease-out cubic: f(t) = 1 - (1 - t)^3
                    const zoomProgress = 1 - Math.pow(1 - Math.min(rawProgress, 1), 3);

                    // Interpolate currentRenderTileSize from the initial zoomed-in size (dynamicTileSize)
                    // to the target normal level size (targetDynamicTileSizeForLevel)
                    currentRenderTileSize = Math.floor(dynamicTileSize - ((dynamicTileSize - targetDynamicTileSizeForLevel) * zoomProgress));

                    // Clamp currentRenderTileSize to prevent it from getting too large or small
                    currentRenderTileSize = Math.max(1, currentRenderTileSize); // Ensure it's at least 1 pixel

                    // Update offsets based on the current animated tile size
                    currentRenderOffsetX = Math.floor((gameCanvas.width / 2 - currentRenderTileSize / 2) - (player.x * currentRenderTileSize));
                    currentRenderOffsetY = Math.floor((gameCanvas.height / 2 - currentRenderTileSize / 2) - (player.y * currentRenderTileSize));

                    if (zoomProgress >= 1) {
                        gameStartZoomActive = false;
                        // Once zoom-out is complete, ensure dynamicTileSize is set to its final, level-appropriate value
                        dynamicTileSize = targetDynamicTileSizeForLevel;
                    }
                } else {
                    // Default case: no specific zoom animation active
                    currentRenderTileSize = Math.floor(dynamicTileSize); // Use the base dynamicTileSize
                    
                    // Default case: no specific zoom animation active
                    currentRenderTileSize = Math.floor(dynamicTileSize); // Use the base dynamicTileSize
                    currentRenderOffsetX = Math.floor((gameCanvas.width / 2 - dynamicTileSize / 2) - (player.x * dynamicTileSize));
                    currentRenderOffsetY = Math.floor((gameCanvas.height / 2 - dynamicTileSize / 2) - (player.y * dynamicTileSize));
                }

                // Ensure all drawing dimensions are integers to prevent sub-pixel rendering artifacts
                currentRenderTileSize = Math.floor(currentRenderTileSize);
                currentRenderOffsetX = Math.floor(currentRenderOffsetX);
                currentRenderOffsetY = Math.floor(currentRenderOffsetY);

                const totalMapPixelWidth = dynamicMapWidth * currentRenderTileSize;
                const totalMapPixelHeight = dynamicMapHeight * currentRenderTileSize;

                // Remove camera clamping to allow viewing beyond map boundaries (void space)
                // currentRenderOffsetX = Math.max(gameCanvas.width - totalMapPixelWidth, Math.min(0, currentRenderOffsetX));
                // currentRenderOffsetY = Math.max(gameCanvas.height - totalMapPixelHeight, Math.min(0, currentRenderOffsetY));

                // Calculate the range of tiles to draw to fill the entire screen
                const startTileX = Math.floor(-currentRenderOffsetX / currentRenderTileSize) - 1;
                const endTileX = Math.ceil((gameCanvas.width - currentRenderOffsetX) / currentRenderTileSize) + 1;
                const startTileY = Math.floor(-currentRenderOffsetY / currentRenderTileSize) - 1;
                const endTileY = Math.ceil((gameCanvas.height - currentRenderOffsetY) / currentRenderTileSize) + 1;

                for (let y = startTileY; y < endTileY; y++) {
                    for (let x = startTileX; x < endTileX; x++) {
                        const tileDrawX = Math.floor(x * currentRenderTileSize + currentRenderOffsetX);
                        const tileDrawY = Math.floor(y * currentRenderTileSize + currentRenderOffsetY);
                        const tileSize = Math.floor(currentRenderTileSize);

                        // Check if this tile is within the actual map bounds
                        if (x >= 0 && x < dynamicMapWidth && y >= 0 && y < dynamicMapHeight) {
                            const tileType = gameMap[y][x];
                            switch (tileType) {
                                case TILE_WALL:
                                    ctx.fillStyle = COLOR_WALL;
                                    ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                    break;
                                case TILE_FLOOR:
                                    ctx.fillStyle = COLOR_FLOOR;
                                    ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                    break;
                                case TILE_STAIRS:
                                    // Stairs color is now dynamic based on level
                                    const stairsHealthRatio = currentLevel / ZOOM_LEVELS_EFFECTIVE; // Use currentLevel for stairs "health"
                                    const currentStairsColor = getHealthColor(FIXED_COLOR_STAIRS, currentLevel, ZOOM_LEVELS_EFFECTIVE); // Pass currentLevel as value, ZOOM_LEVELS_EFFECTIVE as threshold
                                    ctx.fillStyle = currentStairsColor;
                                    ctx.fillRect(tileDrawX, tileDrawY, tileSize, tileSize);
                                    break;
                            }
                        }
                        // Outside map bounds = void space (already black from canvas clear)
                    }
                }



                const stairsCanvasX = stairs.x * currentRenderTileSize + currentRenderOffsetX;
                const stairsCanvasY = stairs.y * currentRenderTileSize + currentRenderOffsetY;
                const areStairsOnScreen = stairsCanvasX >= -currentRenderTileSize && stairsCanvasX < gameCanvas.width &&
                                           stairsCanvasY >= -currentRenderTileSize && stairsCanvasY < gameCanvas.height;

                // Calculate opacity and font weight for stairs based on currentLevel
                const stairsOpacity = getOpacity(currentLevel, ZOOM_LEVELS_EFFECTIVE); // Pass currentLevel as value, ZOOM_LEVELS_EFFECTIVE as threshold
                const stairsFontWeight = getFontWeight(currentLevel, ZOOM_LEVELS_EFFECTIVE); // Pass currentLevel as value, ZOOM_LEVELS_EFFECTIVE as threshold
                const currentStairsColor = getHealthColor(FIXED_COLOR_STAIRS, currentLevel, ZOOM_LEVELS_EFFECTIVE); // Use dynamic color for stairs

                if (areStairsOnScreen) {
                    // Check if any enemy is on the door tile
                    const enemyOnDoor = enemies.some(enemy => enemy.x === stairs.x && enemy.y === stairs.y);
                    
                    // Determine door/stairs state
                    // Door is locked if key not collected OR triangle is still flying to unlock it
                    const isLocked = (key && !key.collected) || triangleFlyActive;
                    const isAnimating = doorAnimActive;
                    
                    // Start shake animation if enemy is on door (regardless of lock state)
                    if (enemyOnDoor && !doorShakeActive && !isAnimating) {
                        doorShakeActive = true;
                        doorShakeStartTime = performance.now();
                    }
                    
                    // Calculate animation progress
                    let animProgress = 0;
                    if (isAnimating) {
                        const now = performance.now();
                        const elapsed = now - doorAnimStartTime;
                        animProgress = Math.min(elapsed / doorAnimDuration, 1.0);
                        
                        if (animProgress >= 1.0) {
                            doorAnimActive = false; // Animation complete
                        }
                    }
                    
                    if (isLocked && !isAnimating) {
                        // Closed door with shake animation (only when actually locked)
                        ctx.save();
                        ctx.globalAlpha = stairsOpacity;
                        ctx.fillStyle = '#8B4513'; // Brown door
                        
                        let doorX = stairsCanvasX;
                        let doorY = stairsCanvasY;
                        
                        // Apply shake animation if active
                        if (doorShakeActive) {
                            const now = performance.now();
                            const elapsed = now - doorShakeStartTime;
                            const shakeProgress = Math.min(elapsed / doorShakeDuration, 1.0);
                            
                            if (shakeProgress >= 1.0) {
                                doorShakeActive = false; // Animation complete
                            } else {
                                // Slow, drastic side-to-side "head shaking no" motion
                                const shakeIntensity = Math.floor(currentRenderTileSize * 0.4); // Even more drastic - 40% of tile size
                                const shakeFreq = 4; // Much slower - only 4 complete shakes over duration
                                const shakeFade = Math.pow(1.0 - shakeProgress, 0.3); // Very slow fade
                                
                                // Only horizontal shake - pure side-to-side motion
                                const shakeOffset = Math.sin(shakeProgress * Math.PI * shakeFreq) * shakeIntensity * shakeFade;
                                doorX += shakeOffset;
                            }
                        }
                        
                        ctx.fillRect(Math.floor(doorX), Math.floor(doorY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                        
                        // Draw triangle-shaped lock in the center (half the size of the triangle key)
                        const lockSize = Math.floor(currentRenderTileSize * 0.2); // Half of triangle size (0.4 * 0.5)
                        const lockCenterX = Math.floor(doorX + currentRenderTileSize / 2);
                        const lockCenterY = Math.floor(doorY + currentRenderTileSize / 2);
                        
                        ctx.fillStyle = '#654321'; // Darker brown for lock
                        ctx.beginPath();
                        ctx.moveTo(lockCenterX, lockCenterY - lockSize); // Top point
                        ctx.lineTo(lockCenterX - lockSize, lockCenterY + lockSize); // Bottom left
                        ctx.lineTo(lockCenterX + lockSize, lockCenterY + lockSize); // Bottom right
                        ctx.closePath();
                        ctx.fill();
                        
                        // Draw lighter outline for the lock to make it more visible
                        ctx.strokeStyle = '#A0522D'; // Lighter brown outline
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Draw small padlock inside the triangle
                        const padlockSize = Math.max(2, Math.floor(lockSize * 0.4)); // Padlock is 40% of triangle size
                        const padlockX = lockCenterX;
                        const padlockY = lockCenterY + Math.floor(lockSize * 0.2); // Slightly below center
                        
                        // Padlock body (rectangle)
                        ctx.fillStyle = '#2C1810'; // Very dark brown/black for padlock
                        ctx.fillRect(padlockX - padlockSize, padlockY - padlockSize/2, padlockSize * 2, padlockSize);
                        
                        // Padlock shackle (U-shape)
                        ctx.strokeStyle = '#2C1810';
                        ctx.lineWidth = Math.max(1, Math.floor(padlockSize * 0.3));
                        ctx.beginPath();
                        const shackleWidth = Math.floor(padlockSize * 0.8);
                        const shackleHeight = Math.floor(padlockSize * 0.6);
                        ctx.arc(padlockX, padlockY - padlockSize/2, shackleWidth, Math.PI, 0, false); // Half circle on top
                        ctx.stroke();
                        
                        ctx.restore();
                    } else if (isAnimating) {
                        // Door opening animation with smooth scaling and fading
                        ctx.save();
                        
                        // Smooth animation curves
                        const smoothProgress = animProgress; // Linear for now, could add easing
                        
                        // Calculate screen diagonal to ensure we fill the entire screen
                        const screenDiagonal = Math.sqrt(gameCanvas.width * gameCanvas.width + gameCanvas.height * gameCanvas.height);
                        const maxScale = screenDiagonal / currentRenderTileSize; // Scale needed to fill entire screen
                        
                        const sizeScale = 1.0 + (smoothProgress * maxScale); // Grow from 1.0x to fill entire screen
                        const doorFade = Math.max(0, 1.0 - (smoothProgress * 1.5)); // Doors fade out faster
                        const stairsFade = Math.max(0, 1.0 - (smoothProgress * 1.2)); // Stairs fade out as they grow
                        const overallFade = Math.max(0, 1.0 - (smoothProgress * 0.8)); // Overall fading effect
                        const glowIntensity = Math.min(1.0, smoothProgress * 2.0); // Glow builds up
                        
                        // Calculate scaled door dimensions
                        const scaledSize = currentRenderTileSize * sizeScale;
                        const centerX = stairsCanvasX + currentRenderTileSize / 2;
                        const centerY = stairsCanvasY + currentRenderTileSize / 2;
                        const scaledX = centerX - scaledSize / 2;
                        const scaledY = centerY - scaledSize / 2;
                        
                        // Draw green stairs background (what's revealed as doors slide apart)
                        ctx.globalAlpha = stairsOpacity * stairsFade * overallFade;
                        ctx.fillStyle = currentStairsColor;
                        ctx.fillRect(Math.floor(scaledX), Math.floor(scaledY), Math.floor(scaledSize), Math.floor(scaledSize));
                        
                        // Calculate door slide progress and positions
                        const doorSlideProgress = Math.min(1.0, smoothProgress * 1.5); // Doors slide faster than scale
                        const slideDistance = scaledSize * doorSlideProgress; // How far each door moves
                        const doorWidth = Math.floor(scaledSize * 0.5); // Each door is half the width
                        
                        // Draw the sliding door panels
                        if (doorFade > 0.01) {
                            ctx.globalAlpha = stairsOpacity * doorFade * overallFade;
                            ctx.fillStyle = '#8B4513'; // Brown door panels
                            
                            // Left door sliding left (moves further left as animation progresses)
                            const leftDoorX = Math.floor(scaledX - slideDistance);
                            ctx.fillRect(leftDoorX, Math.floor(scaledY), doorWidth, Math.floor(scaledSize));
                            
                            // Right door sliding right (moves further right as animation progresses)  
                            const rightDoorX = Math.floor(scaledX + scaledSize + slideDistance - doorWidth);
                            ctx.fillRect(rightDoorX, Math.floor(scaledY), doorWidth, Math.floor(scaledSize));
                            
                            // Draw vertical lines on the inner edges of each door panel (the seam)
                            if (doorSlideProgress < 0.9) { // Only draw lines when doors are still somewhat visible
                                ctx.strokeStyle = '#654321'; // Darker brown for door lines
                                ctx.lineWidth = Math.max(1, Math.floor(scaledSize * 0.02));
                                ctx.beginPath();
                                
                                // Line on right edge of left door
                                const leftEdgeX = Math.floor(leftDoorX + doorWidth);
                                ctx.moveTo(leftEdgeX, Math.floor(scaledY));
                                ctx.lineTo(leftEdgeX, Math.floor(scaledY + scaledSize));
                                
                                // Line on left edge of right door
                                const rightEdgeX = rightDoorX;
                                ctx.moveTo(rightEdgeX, Math.floor(scaledY));
                                ctx.lineTo(rightEdgeX, Math.floor(scaledY + scaledSize));
                                
                                ctx.stroke();
                            }
                        }
                        
                        // Smooth glowing effect
                        if (glowIntensity > 0.1 && overallFade > 0.1) {
                            // Inner glow
                            ctx.globalAlpha = glowIntensity * 0.4 * overallFade;
                            ctx.strokeStyle = currentStairsColor;
                            ctx.lineWidth = Math.max(1, Math.floor(2 + (smoothProgress * 4)));
                            ctx.strokeRect(Math.floor(scaledX - 3), Math.floor(scaledY - 3), Math.floor(scaledSize + 6), Math.floor(scaledSize + 6));
                            
                            // Outer glow (softer)
                            if (glowIntensity > 0.3) {
                                ctx.globalAlpha = glowIntensity * 0.2 * overallFade;
                                ctx.lineWidth = Math.max(1, Math.floor(1 + (smoothProgress * 2)));
                                ctx.strokeRect(Math.floor(scaledX - 6), Math.floor(scaledY - 6), Math.floor(scaledSize + 12), Math.floor(scaledSize + 12));
                            }
                        }
                        
                        ctx.restore();
                    } else {
                        // Open stairs with pronounced pulsating animation
                        ctx.save();
                        ctx.globalAlpha = stairsOpacity;
                        
                        // Calculate pulsating size and color
                        const now = performance.now();
                        const pulseSpeed = 0.006; // Slightly faster pulse
                        const pulseIntensity = 0.25; // 25% size variation (much more pronounced)
                        const pulse = Math.sin(now * pulseSpeed) * pulseIntensity + 1.0; // Oscillates between 0.75 and 1.25
                        
                        // Calculate color brightness variation
                        const colorPulse = Math.sin(now * pulseSpeed) * 0.5 + 0.5; // Oscillates between 0 and 1
                        
                        // Create brighter green color based on pulse
                        const baseColor = currentStairsColor;
                        let pulseColor;
                        
                        // Extract RGB values from hex color and brighten them
                        if (baseColor.startsWith('#')) {
                            const r = parseInt(baseColor.substring(1, 3), 16);
                            const g = parseInt(baseColor.substring(3, 5), 16);
                            const b = parseInt(baseColor.substring(5, 7), 16);
                            
                            // Increase brightness during pulse (make greens brighter)
                            const brightnessFactor = 1.0 + (colorPulse * 0.5); // Up to 50% brighter
                            const newR = Math.min(255, Math.floor(r * brightnessFactor));
                            const newG = Math.min(255, Math.floor(g * brightnessFactor));
                            const newB = Math.min(255, Math.floor(b * brightnessFactor));
                            
                            pulseColor = `rgb(${newR}, ${newG}, ${newB})`;
                        } else {
                            pulseColor = baseColor; // Fallback to base color
                        }
                        
                        // Calculate pulsed dimensions
                        const pulsedSize = currentRenderTileSize * pulse;
                        let centerX = stairsCanvasX + currentRenderTileSize / 2;
                        let centerY = stairsCanvasY + currentRenderTileSize / 2;

                        // Apply shake animation if active (when enemy is on unlocked door)
                        if (doorShakeActive) {
                            const elapsed = now - doorShakeStartTime;
                            const shakeProgress = Math.min(elapsed / doorShakeDuration, 1.0);

                            if (shakeProgress >= 1.0) {
                                doorShakeActive = false; // Animation complete
                            } else {
                                // Same shake parameters as locked door
                                const shakeIntensity = Math.floor(currentRenderTileSize * 0.4);
                                const shakeFreq = 4;
                                const shakeFade = Math.pow(1.0 - shakeProgress, 0.3);
                                const shakeOffset = Math.sin(shakeProgress * Math.PI * shakeFreq) * shakeIntensity * shakeFade;
                                centerX += shakeOffset;
                            }
                        }
                        
                        const pulsedX = centerX - pulsedSize / 2;
                        const pulsedY = centerY - pulsedSize / 2;
                        
                        ctx.fillStyle = pulseColor;
                        ctx.fillRect(Math.floor(pulsedX), Math.floor(pulsedY), Math.floor(pulsedSize), Math.floor(pulsedSize));
                        
                        ctx.restore();
                    }

                    // Draw the level number in top right corner (always visible)
                    ctx.save();
                    ctx.globalAlpha = stairsOpacity;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${stairsFontWeight} ${Math.floor(currentRenderTileSize * 0.4)}px VT323`; // Smaller font for corner placement
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'top';
                    const numberX = Math.floor(stairsCanvasX + currentRenderTileSize - 2); // 2px padding from right edge
                    const numberY = Math.floor(stairsCanvasY + 2); // 2px padding from top edge
                    ctx.fillText(currentLevel + 1, numberX, numberY);
                    ctx.restore();
                } else {
                    const enemyOnDoorOffScreen = enemies.some(enemy => enemy.x === stairs.x && enemy.y === stairs.y);
                    const isLocked = key && !key.collected && !doorAnimActive;
                    const shouldShowAsClosed = isLocked || enemyOnDoorOffScreen;
                    const indicatorColor = shouldShowAsClosed ? '#8B4513' : currentStairsColor; // Brown for closed door, normal color for open stairs
                    drawOffScreenIndicator(stairs, indicatorColor, currentRenderOffsetX, currentRenderOffsetY, stairsOpacity);
                }

                // Draw remote control (flying animation or original position)
                if (key && (!key.collected || triangleFlyActive)) {
                    let renderX, renderY, renderSize, renderRotation = 0;
                    
                    if (triangleFlyActive) {
                        // Flying animation - triangle moves from key position to door
                        const now = performance.now();
                        const elapsed = now - triangleFlyStartTime;
                        const flyProgress = Math.min(elapsed / triangleFlyDuration, 1.0);
                        
                        if (flyProgress >= 1.0) {
                            triangleFlyActive = false; // Animation complete
                        }
                        
                        // Smooth easing for flight path
                        const easedProgress = 1 - Math.pow(1 - flyProgress, 3); // Ease-out cubic
                        
                        // Interpolate position
                        const currentX = triangleFlyStartPos.x + (triangleFlyEndPos.x - triangleFlyStartPos.x) * easedProgress;
                        const currentY = triangleFlyStartPos.y + (triangleFlyEndPos.y - triangleFlyStartPos.y) * easedProgress;
                        
                        renderX = currentX * currentRenderTileSize + currentRenderOffsetX;
                        renderY = currentY * currentRenderTileSize + currentRenderOffsetY;
                        renderSize = Math.floor(currentRenderTileSize * 0.4 * (1 + flyProgress * 0.5)); // Grows slightly while flying
                        renderRotation = flyProgress * 4 * Math.PI; // Two full rotations during flight
                        
                    } else if (!key.collected) {
                        // Normal static position
                        renderX = key.x * currentRenderTileSize + currentRenderOffsetX;
                        renderY = key.y * currentRenderTileSize + currentRenderOffsetY;
                        
                        // Base size with subtle pulsing animation
                        const now = performance.now();
                        const baseSize = currentRenderTileSize * 0.4;
                        
                        // Check if enemies are on the door for enhanced pulsing
                        const enemyOnDoor = enemies.some(enemy => enemy.x === stairs.x && enemy.y === stairs.y);
                        
                        // Subtle pulse animation - always active
                        let pulseIntensity = 0.05; // 5% size variation normally
                        let pulseSpeed = 0.008; // Faster pulse normally
                        
                        if (enemyOnDoor) {
                            pulseIntensity = 0.15; // 15% size variation when enemy on door
                            pulseSpeed = 0.015; // Much faster pulse when enemy on door
                        }
                        
                        const pulse = Math.sin(now * pulseSpeed) * pulseIntensity + 1.0;
                        renderSize = Math.floor(baseSize * pulse);
                        
                        // Apply rotation when door shakes
                        if (doorShakeActive) {
                            const elapsed = now - doorShakeStartTime;
                            const rotationProgress = Math.min(elapsed / doorShakeDuration, 1.0);
                            renderRotation = rotationProgress * 2 * Math.PI; // One full rotation
                        }
                    }
                    
                    // Check if triangle should be rendered on screen
                    const isOnScreen = renderX >= -currentRenderTileSize && renderX < gameCanvas.width &&
                                      renderY >= -currentRenderTileSize && renderY < gameCanvas.height;

                    // Determine if triangle should be rendered and where
                    let shouldRender = isOnScreen;
                    let renderInLock = false;
                    
                    if (triangleFlyActive) {
                        const now = performance.now();
                        const elapsed = now - triangleFlyStartTime;
                        const flyProgress = Math.min(elapsed / triangleFlyDuration, 1.0);
                        
                        // Show triangle landing in lock when flight is nearly complete
                        if (flyProgress > 0.8) {
                            shouldRender = true;
                            renderInLock = true;
                        }
                    } else if (key.collected && !doorAnimActive) {
                        // Show triangle in lock after flight but before door opens
                        shouldRender = true;
                        renderInLock = true;
                    } else if (doorAnimActive) {
                        // Don't render triangle at all during door opening animation
                        shouldRender = false;
                    }

                    if (shouldRender) {
                        ctx.save();
                        ctx.fillStyle = '#00BFFF'; // Blue color for remote control
                        
                        let centerX, centerY, triangleSize;
                        
                        if (renderInLock) {
                            // Position triangle in the door lock
                            const doorCanvasX = stairs.x * currentRenderTileSize + currentRenderOffsetX;
                            const doorCanvasY = stairs.y * currentRenderTileSize + currentRenderOffsetY;
                            centerX = Math.floor(doorCanvasX + currentRenderTileSize / 2);
                            centerY = Math.floor(doorCanvasY + currentRenderTileSize / 2);
                            triangleSize = Math.floor(currentRenderTileSize * 0.2); // Same size as the lock
                        } else {
                            // Normal triangle rendering
                            centerX = Math.floor(renderX + currentRenderTileSize / 2);
                            centerY = Math.floor(renderY + currentRenderTileSize / 2);
                            triangleSize = renderSize;
                            
                            // Apply fading effect during flight
                            if (triangleFlyActive) {
                                const now = performance.now();
                                const elapsed = now - triangleFlyStartTime;
                                const flyProgress = Math.min(elapsed / triangleFlyDuration, 1.0);
                                
                                // Fade out progressively as it approaches the door
                                let alpha = 1.0 - flyProgress; // Fade from 1.0 to 0.0 over entire flight
                                ctx.globalAlpha = alpha;
                            }
                            
                            // Apply rotation if needed
                            if (renderRotation !== 0) {
                                ctx.translate(centerX, centerY);
                                ctx.rotate(renderRotation);
                                ctx.translate(-centerX, -centerY);
                            }
                        }
                        
                        // Draw triangle
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY - triangleSize); // Top point
                        ctx.lineTo(centerX - triangleSize, centerY + triangleSize); // Bottom left
                        ctx.lineTo(centerX + triangleSize, centerY + triangleSize); // Bottom right
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.restore();
                    } else if (!key.collected) {
                        drawOffScreenIndicator(key, '#00BFFF', currentRenderOffsetX, currentRenderOffsetY, 1.0);
                    }
                }

                enemies.forEach(enemy => {
                    const enemyCanvasX = enemy.x * currentRenderTileSize + currentRenderOffsetX;
                    const enemyCanvasY = enemy.y * currentRenderTileSize + currentRenderOffsetY;

                    const isEnemyOnScreen = enemyCanvasX >= -currentRenderTileSize && enemyCanvasX < gameCanvas.width &&
                                            enemyCanvasY >= -currentRenderTileSize && enemyCanvasY < gameCanvas.height;

                    let currentEnemyThrustOffsetX = 0;
                    let currentEnemyThrustOffsetY = 0;
                    let enemyHealthOpacity = 1;

                    if (enemy.thrustAnimActive) {
                        const elapsed = (now - enemy.thrustAnimStartTime) * timeScale; // Apply timeScale
                        if (elapsed < enemy.thrustAnimDuration) {
                            const progress = elapsed / enemy.thrustAnimDuration;
                            const thrustFactor = Math.sin(progress * Math.PI); // Smooth forward and back
                            const displacementMagnitude = currentRenderTileSize * 0.4 * enemy.thrustAnimMagnitude; // Max thrust is 40% of tile size, scaled by damage
                            currentEnemyThrustOffsetX = enemy.thrustAnimDirectionX * thrustFactor * displacementMagnitude;
                            currentEnemyThrustOffsetY = enemy.thrustAnimDirectionY * thrustFactor * displacementMagnitude;
                            enemyHealthOpacity = 1 - (progress * 0.5); // Fade out slightly
                        } else {
                            enemy.thrustAnimActive = false; // Animation finished
                        }
                    }

                    // Calculate health ratio for enemy color and font
                    let currentEnemyColor = getHealthColor(FIXED_COLOR_ENEMY, enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Base color based on health

                    // Calculate enemy flow for blinking effect
                    // MODIFIED: Enemy flow now uses flowLevel if no damage taken, otherwise damage taken flow.
                    const enemyVisualFlow = enemy.totalDamageTakenByThisEnemy > 0
                        ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1) // Ensure no division by zero
                        : enemy.flowLevel; // Use initial flowLevel if no damage taken yet

                    const enemyFlowIntensity = Math.min(1, enemyVisualFlow); // Cap intensity at 1 flow

                    let enemyFlowScale = 1;
                    if (enemyFlowIntensity > 0) {
                        // Invert flow intensity for blink speed: higher flow -> smaller blink speed (faster)
                        const minBlinkSpeed = 50; // Fastest blink speed (for flowIntensity = 1)
                        const maxBlinkSpeed = 200; // Slowest blink speed (for flowIntensity = 0, effectively)
                        const currentBlinkSpeed = maxBlinkSpeed - (maxBlinkSpeed - minBlinkSpeed) * enemyFlowIntensity;
                        const blinkFactor = (Math.sin(now / currentBlinkSpeed) + 1) / 2; // Smooth pulse from 0 to 1

                        // Convert currentEnemyColor to HSL to modulate it for blinking
                        let [h_e, s_e, l_e] = hexToHsl(currentEnemyColor);

                        // Apply saturation boost based on blinkFactor and flowIntensity
                        const maxSaturationBoost_e = 50; // Increased for more obvious effect, same as player
                        s_e = s_e + (blinkFactor * enemyFlowIntensity * maxSaturationBoost_e);
                        s_e = Math.min(100, s_e); // Clamp saturation

                        // Apply a subtle lightness pulse, making it slightly brighter at the peak of the blink
                        const maxLightnessPulse_e = 20; // Increased for more obvious effect, same as player
                        l_e = l_e + (blinkFactor * enemyFlowIntensity * maxLightnessPulse_e);
                        l_e = Math.min(100, l_e); // Clamp lightness

                        currentEnemyColor = hslToHex(h_e, s_e, l_e);

                        enemyFlowScale = 1 + (enemyFlowIntensity * 0.1 * blinkFactor); // Apply size pulse based on flow
                    }


                    const enemyFontWeight = getFontWeight(enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Pass current health and threshold
                    const enemyOpacity = getOpacity(enemy.health, ENEMY_VISUAL_HEALTH_THRESHOLD); // Get opacity based on health

                    if (isEnemyOnScreen) {
                        // Draw enemy square
                        ctx.save();
                        ctx.globalAlpha = enemyOpacity;
                        ctx.fillStyle = currentEnemyColor;
                        ctx.fillRect(Math.floor(enemyCanvasX), Math.floor(enemyCanvasY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                        ctx.restore();

                        // Draw enemy health number
                        ctx.save();
                        ctx.globalAlpha = enemyHealthOpacity;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = `${enemyFontWeight} ${Math.floor(currentRenderTileSize * 0.5 * enemyFlowScale)}px VT323`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(enemy.health, Math.floor(enemyCanvasX + currentRenderTileSize / 2 + currentEnemyThrustOffsetX), Math.floor(enemyCanvasY + currentRenderTileSize / 2 + currentEnemyThrustOffsetY));
                        ctx.restore();

                        // Draw enemy name in a crisp font at the bottom of the square
                        ctx.save();
                        ctx.globalAlpha = 1;  // Full opacity for better legibility
                        // Crisp font with slightly reduced weight
                        ctx.font = `${Math.max(8, Math.floor(currentRenderTileSize * 0.25))}px 'VT323'`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';  // Align to bottom of the square
                        // Draw black outline first for better contrast
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeText(enemy.name, 
                            Math.floor(enemyCanvasX + currentRenderTileSize / 2),
                            Math.floor(enemyCanvasY + currentRenderTileSize));
                        // Then draw white text
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText(enemy.name, 
                            Math.floor(enemyCanvasX + currentRenderTileSize / 2),
                            Math.floor(enemyCanvasY + currentRenderTileSize));
                        ctx.restore();
                    } else {
                        drawOffScreenIndicator(enemy, currentEnemyColor, currentRenderOffsetX, currentRenderOffsetY, enemyOpacity); // Indicator also uses dynamic color and opacity
                    }
                });

                let currentHealthTextScale = 1;
                const healthAnimDuration = 200;
                if (player.healthAnimStartTime > 0 && (now - player.healthAnimStartTime) * timeScale < healthAnimDuration) { // Apply timeScale
                    const progress = ((now - player.healthAnimStartTime) * timeScale) / healthAnimDuration;
                    if (progress < 0.5) {
                        currentHealthTextScale = 1 + (0.5 * progress * 2);
                    } else {
                        currentHealthTextScale = 1.5 - (0.5 * (progress - 0.5) * 2);
                    }
                } else {
                    player.healthAnimStartTime = 0;
                }

                let currentPlayerThrustOffsetX = 0;
                let currentPlayerThrustOffsetY = 0;
                let playerHealthOpacity = 1;

                if (player.thrustAnimActive) {
                    const elapsed = (now - player.thrustAnimStartTime) * timeScale; // Apply timeScale
                    if (elapsed < player.thrustAnimDuration) {
                        const progress = elapsed / player.thrustAnimDuration;
                        const thrustFactor = Math.sin(progress * Math.PI); // Smooth forward and back
                        const displacementMagnitude = currentRenderTileSize * 0.4 * player.thrustAnimMagnitude; // Max thrust is 40% of tile size, scaled by damage
                        currentPlayerThrustOffsetX = player.thrustAnimDirectionX * thrustFactor * displacementMagnitude;
                        currentPlayerThrustOffsetY = player.thrustAnimDirectionY * thrustFactor * displacementMagnitude;
                        playerHealthOpacity = 1 - (progress * 0.5); // Fade out slightly
                    } else {
                        player.thrustAnimActive = false; // Animation finished
                    }
                }

                // Calculate health ratio for player color and font
                let currentPlayerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Base color based on health

                // Calculate player flow for blinking effect
                playerFlow = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0; // Assign to the global playerFlow
                const flowIntensity = Math.min(1, playerFlow); // Cap intensity at 1 flow

                let playerFlowScale = 1; // Initialize playerFlowScale
                if (flowIntensity > 0) {
                    // Invert flow intensity for blink speed: higher flow -> smaller blink speed (faster)
                    const minBlinkSpeed = 50; // Fastest blink speed (for flowIntensity = 1)
                    const maxBlinkSpeed = 200; // Slowest blink speed (for flowIntensity = 0, effectively)
                    const currentBlinkSpeed = maxBlinkSpeed - (maxBlinkSpeed - minBlinkSpeed) * flowIntensity;
                    const blinkFactor = (Math.sin(now / currentBlinkSpeed) + 1) / 2; // Smooth pulse from 0 to 1

                    // Convert currentPlayerColor to HSL to modulate it for blinking
                    let [h, s, l] = hexToHsl(currentPlayerColor);

                    // Apply saturation boost based on blinkFactor and flowIntensity
                    const maxSaturationBoost = 50; // Increased for more obvious effect
                    s = s + (blinkFactor * flowIntensity * maxSaturationBoost);
                    s = Math.min(100, s); // Clamp saturation

                    // Apply a subtle lightness pulse, making it slightly brighter at the peak of the blink
                    const maxLightnessPulse = 20; // Increased for more obvious effect
                    l = l + (blinkFactor * flowIntensity * maxLightnessPulse);
                    l = Math.min(100, l); // Clamp lightness

                    currentPlayerColor = hslToHex(h, s, l);

                    playerFlowScale = 1 + (flowIntensity * 0.1 * blinkFactor); // Apply size pulse based on flow
                }

                const playerFontWeight = getFontWeight(player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Pass current health and threshold
                const playerOpacity = getOpacity(player.health, PLAYER_VISUAL_HEALTH_THRESHOLD); // Get opacity based on health

                // Only draw player if not game over (player explodes and is no longer drawn as a solid block)
                    if (!gameOver) {
                        // Draw player square
                        ctx.save();
                        ctx.globalAlpha = playerOpacity;
                        ctx.fillStyle = currentPlayerColor;
                        ctx.fillRect(Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX), Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY), Math.floor(currentRenderTileSize), Math.floor(currentRenderTileSize));
                        
                        // Draw player name in a crisp font at the bottom of the square
                        ctx.save();
                        ctx.globalAlpha = 1;  // Full opacity for better legibility
                        // Crisp font with slightly reduced weight
                        ctx.font = `${Math.max(8, Math.floor(currentRenderTileSize * 0.25))}px 'VT323'`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';  // Align to bottom of the square
                        // Draw black outline first for better contrast
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeText(player.name, 
                            Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2), 
                            Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize));
                        // Then draw white text
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText(player.name, 
                            Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2), 
                            Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize));
                        ctx.restore();
                        ctx.restore();
                    ctx.save(); // Save context again for text opacity
                    ctx.globalAlpha = playerHealthOpacity; // Apply thrust animation opacity
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${playerFontWeight} ${Math.floor(currentRenderTileSize * 0.5 * currentHealthTextScale * playerFlowScale)}px VT323`; // Use dynamic font weight and flow scale
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(player.health, Math.floor(player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + currentPlayerThrustOffsetX), Math.floor(player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + currentPlayerThrustOffsetY));
                    ctx.restore(); // Restore context
                }


                for (let i = activeExplosions.length - 1; i >= 0; i--) {
                    const explosion = activeExplosions[i];
                    const elapsed = (now - explosion.startTime) * timeScale; // Apply timeScale
                    const progress = elapsed / explosion.duration;

                    if (progress >= 1) {
                        activeExplosions.splice(i, 1);
                        continue;
                    }

                    for (let j = explosion.particles.length - 1; j >= 0; j--) {
                        const particle = explosion.particles[j];
                        const particleProgress = ((now - particle.startTime) * timeScale) / particle.duration; // Apply timeScale

                        if (particleProgress >= 1) {
                            continue;
                        }

                        // Calculate current size of the particle (shrinks over time)
                        const initialParticleSize = currentRenderTileSize * 0.2; // Starting size for fragments
                        const currentParticleSize = initialParticleSize * (1 - particleProgress * 0.7); // Shrink more significantly

                        const currentX = particle.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + particle.initialVelocityX * elapsed;
                        const currentY = particle.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + particle.initialVelocityY * elapsed;

                        ctx.save();
                        ctx.globalAlpha = (1 - particleProgress) * particle.fadeFactor; // Apply random fade factor
                        ctx.fillStyle = particle.color;
                        ctx.fillRect(Math.floor(currentX - currentParticleSize / 2), Math.floor(currentY - currentParticleSize / 2), Math.floor(currentParticleSize), Math.floor(currentParticleSize));
                        ctx.restore();
                    }
                }

                // Draw static pickups (including player remains)
                // Note: Text alignment is now set individually for each pickup to position them at corners
                staticDamageNumbers.forEach(staticNum => {
                    if (staticNum.parts && staticNum.parts.length > 0) {
                        staticNum.parts.forEach(part => {
                            let writhingXOffset = 0;
                            let writhingYOffset = 0;
                            if (staticNum.isPlayerRemains) {
                                writhingXOffset = Math.cos(staticNum.writhingOffsetAngle + now * staticNum.writhingSpeed) * staticNum.writhingOffsetRadius;
                                writhingYOffset = Math.sin(staticNum.writhingOffsetAngle + now * staticNum.writhingSpeed) * staticNum.writhingOffsetRadius;
                            }

                            // Position pickup numbers around the edges of the tile to avoid center overlap with agent health
                            // Use a hash of the pickup position to deterministically place it in a corner
                            // Player remains stay centered for visibility
                            let cornerOffsetX, cornerOffsetY, textAlign, textBaseline;
                            
                            if (staticNum.isPlayerRemains) {
                                // Keep player remains centered and visible
                                cornerOffsetX = currentRenderTileSize / 2;
                                cornerOffsetY = currentRenderTileSize / 2;
                                textAlign = 'center';
                                textBaseline = 'middle';
                            } else {
                                // Position regular pickups in corners based on position hash
                                const positionHash = (staticNum.x * 31 + staticNum.y * 17) % 4; // Generate 0-3 for four corners
                                const edgeMargin = Math.max(4, Math.floor(currentRenderTileSize * 0.1)); // Small margin from tile edge
                                
                                switch (positionHash) {
                                    case 0: // Top-left
                                        cornerOffsetX = edgeMargin;
                                        cornerOffsetY = edgeMargin;
                                        textAlign = 'left';
                                        textBaseline = 'top';
                                        break;
                                    case 1: // Top-right
                                        cornerOffsetX = currentRenderTileSize - edgeMargin;
                                        cornerOffsetY = edgeMargin;
                                        textAlign = 'right';
                                        textBaseline = 'top';
                                        break;
                                    case 2: // Bottom-left
                                        cornerOffsetX = edgeMargin;
                                        cornerOffsetY = currentRenderTileSize - edgeMargin;
                                        textAlign = 'left';
                                        textBaseline = 'bottom';
                                        break;
                                    case 3: // Bottom-right
                                        cornerOffsetX = currentRenderTileSize - edgeMargin;
                                        cornerOffsetY = currentRenderTileSize - edgeMargin;
                                        textAlign = 'right';
                                        textBaseline = 'bottom';
                                        break;
                                }
                            }
                            
                            const drawX = staticNum.x * currentRenderTileSize + currentRenderOffsetX + cornerOffsetX + part.offsetX + writhingXOffset;
                            const drawY = staticNum.y * currentRenderTileSize + currentRenderOffsetY + cornerOffsetY + part.offsetY + writhingYOffset;
                            
                            // Determine color based on type of pickup
                            ctx.fillStyle = staticNum.isPlayerRemains ? staticNum.playerDeathColor : '#CCCC00'; // Use playerDeathColor if it's player remains

                            // Apply font weight based on pickup value - make pickups smaller and less bold
                            const pickupFontWeight = staticNum.isPlayerRemains ? 600 : Math.max(400, getFontWeight(part.content.value, currentLevel > 0 ? currentLevel : 1) - 200);
                            
                            // Make pickup font size much smaller to avoid overlaps
                            const baseFontSize = Math.floor(currentRenderTileSize * 0.3); // Reduced from 0.6 to 0.3
                            const minFontSize = Math.max(10, Math.floor(currentRenderTileSize * 0.25)); // Much smaller minimum
                            const pickupFontSize = Math.max(minFontSize, baseFontSize);
                            
                            ctx.font = `${pickupFontWeight} ${pickupFontSize}px VT323`;

                            // IMPORTANT: Remove yellow background squares
                            // Clear any canvas effects that might create backgrounds
                            ctx.save(); // Save current state
                            ctx.shadowBlur = 0;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;
                            ctx.shadowColor = 'transparent';
                            ctx.globalAlpha = 1; // Ensure no alpha blending issues
                            ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
                            
                            // Set text alignment based on corner position
                            ctx.textAlign = textAlign;
                            ctx.textBaseline = textBaseline;
                            
                            // Draw either number or symbol
                            if (part.content.type === 'number') {
                                ctx.fillText(part.content.value, Math.floor(drawX), Math.floor(drawY));
                            } else if (part.content.type === 'symbol') {
                                ctx.fillText(part.content.value, Math.floor(drawX), Math.floor(drawY));
                            }
                            
                            ctx.restore(); // Restore previous state
                        });
                    }
                });

                // Drawing activeDamageTextAnimations
                for (let i = activeDamageTextAnimations.length - 1; i >= 0; i--) {
                    const anim = activeDamageTextAnimations[i];
                    const elapsed = (now - anim.startTime) * timeScale; // Apply timeScale

                    if (elapsed < anim.delay) {
                        continue;
                    }

                    const effectiveElapsed = elapsed - anim.delay;
                    const progress = effectiveElapsed / anim.duration;

                    if (progress >= 1) {
                        activeDamageTextAnimations.splice(i, 1);
                        continue;
                    }

                    const opacity = 1 - progress;
                    const moveDistance = currentRenderTileSize * 1.2 * progress;

                    const drawX = Math.floor(anim.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.dirX * moveDistance);
                    const drawY = Math.floor(anim.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.dirY * moveDistance);

                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = anim.color;
                    const baseFontSize = currentRenderTileSize * 0.6;
                    const scaledFontSize = baseFontSize + (anim.amount * (currentRenderTileSize * 0.05));
                    ctx.font = `${Math.floor(scaledFontSize * (1 - progress * 0.5))}px VT323`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(anim.amount, drawX, drawY); // Draw the damage amount
                    ctx.restore();
                }

                // Drawing activePickupAnimations
                for (let i = activePickupAnimations.length - 1; i >= 0; i--) {
                    const anim = activePickupAnimations[i];
                    const elapsed = (now - anim.startTime) * timeScale; // Apply timeScale
                    const progress = elapsed / anim.duration;

                    if (progress >= 1) {
                        activePickupAnimations.splice(i, 1);
                        continue;
                    }

                    const opacity = 1 - progress;

                    const currentX = anim.startX * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.initialOffsetX + (player.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 - (anim.startX * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2 + anim.initialOffsetX)) * progress;
                    const currentY = anim.startY * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.initialOffsetY + (player.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 - (anim.startY * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2 + anim.initialOffsetY)) * progress;


                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = VINTAGE_GREEN; // Green color for health pickups
                    ctx.font = `${Math.floor(currentRenderTileSize * 0.6 * (1 - progress * 0.5))}px VT323`; // Shrink slightly
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(anim.amount, Math.floor(currentX), Math.floor(currentY));
                    ctx.restore();
                }

                // Drawing teleport beam animation
                if (teleportAnimActive) {
                    const elapsed = now - teleportAnimStartTime;
                    const progress = Math.min(elapsed / teleportAnimDuration, 1.0);
                    
                    if (progress >= 1.0) {
                        teleportAnimActive = false;
                    } else {
                        ctx.save();
                        
                        // Calculate screen positions
                        const startX = teleportStartPos.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2;
                        const startY = teleportStartPos.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2;
                        const endX = teleportEndPos.x * currentRenderTileSize + currentRenderOffsetX + currentRenderTileSize / 2;
                        const endY = teleportEndPos.y * currentRenderTileSize + currentRenderOffsetY + currentRenderTileSize / 2;
                        
                        // Animation phases: fade in (0-0.2), full intensity (0.2-0.8), fade out (0.8-1.0)
                        let intensity;
                        if (progress < 0.2) {
                            intensity = progress / 0.2; // Fade in
                        } else if (progress < 0.8) {
                            intensity = 1.0; // Full intensity
                        } else {
                            intensity = (1.0 - progress) / 0.2; // Fade out
                        }
                        
                        // Get player's exact color
                        const playerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD);
                        
                        // Animation phases: appear (0-0.3), travel (0.3-0.8), fade (0.8-1.0)
                        let beamProgress = 0;
                        let beamIntensity = intensity;
                        
                        if (progress < 0.3) {
                            // Appear phase - beam grows from start
                            beamProgress = progress / 0.3;
                            beamIntensity = beamProgress * intensity;
                        } else if (progress < 0.8) {
                            // Travel phase - beam moves towards end
                            beamProgress = 1.0;
                            const travelProgress = (progress - 0.3) / 0.5;
                            beamIntensity = intensity;
                        } else {
                            // Fade phase - beam shrinks at end
                            beamProgress = 1.0;
                            beamIntensity = intensity * (1.0 - ((progress - 0.8) / 0.2));
                        }
                        
                        // Calculate beam size (player-sized)
                        const beamSize = Math.floor(currentRenderTileSize * 0.8); // Similar to player size
                        const segmentSize = Math.max(4, Math.floor(currentRenderTileSize * 0.2)); // Larger segments
                        
                        // Calculate beam direction and movement
                        const deltaX = endX - startX;
                        const deltaY = endY - startY;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        
                        // Movement animation - beam travels along path during travel phase
                        let travelOffset = 0;
                        if (progress >= 0.3 && progress < 0.8) {
                            travelOffset = ((progress - 0.3) / 0.5) * 0.3; // Move 30% along path
                        }
                        
                        // Draw main beam body
                        ctx.globalAlpha = beamIntensity * 0.8;
                        ctx.fillStyle = playerColor;
                        
                        // Draw beam as thick pixelated line with movement
                        const numSegments = Math.floor(distance / segmentSize);
                        for (let i = 0; i <= numSegments * beamProgress; i++) {
                            const baseProgress = i / numSegments;
                            const segmentProgress = baseProgress + travelOffset;
                            
                            if (segmentProgress > 1.0) continue;
                            
                            const segmentX = Math.floor(startX + deltaX * segmentProgress);
                            const segmentY = Math.floor(startY + deltaY * segmentProgress);
                            
                            // Draw thick cross pattern for beam body
                            const halfBeam = Math.floor(beamSize / 2);
                            
                            // Horizontal bar
                            ctx.fillRect(segmentX - halfBeam, segmentY - segmentSize/2, beamSize, segmentSize);
                            // Vertical bar
                            ctx.fillRect(segmentX - segmentSize/2, segmentY - halfBeam, segmentSize, beamSize);
                        }
                        
                        // Add large square effects at both ends
                        const endSquareSize = Math.floor(currentRenderTileSize * 0.7 * beamIntensity);
                        
                        // Start position square (always visible)
                        ctx.globalAlpha = beamIntensity * 0.9;
                        ctx.fillStyle = playerColor;
                        ctx.fillRect(Math.floor(startX - endSquareSize/2), Math.floor(startY - endSquareSize/2), endSquareSize, endSquareSize);
                        
                        // End position square (appears during travel phase)
                        if (progress >= 0.3) {
                            ctx.fillRect(Math.floor(endX - endSquareSize/2), Math.floor(endY - endSquareSize/2), endSquareSize, endSquareSize);
                        }
                        
                        // Add pulsing outer square glow
                        const pulseIntensity = Math.sin(elapsed * 0.008) * 0.4 + 0.6; // Slower pulse
                        ctx.globalAlpha = beamIntensity * 0.4 * pulseIntensity;
                        const glowSize = endSquareSize + Math.floor(endSquareSize * 0.4);
                        
                        ctx.fillRect(Math.floor(startX - glowSize/2), Math.floor(startY - glowSize/2), glowSize, glowSize);
                        if (progress >= 0.3) {
                            ctx.fillRect(Math.floor(endX - glowSize/2), Math.floor(endY - glowSize/2), glowSize, glowSize);
                        }
                        
                        ctx.restore();
                    }
                }

                // Draw total score in small text on the left
                let scoreFontSize = 20;
                scoreFontSize = 20;
                const scorePadding = 8;
                ctx.save();
                ctx.font = `bold ${scoreFontSize}px monospace`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = '#fff';
                // Ensure text is on screen
                ctx.fillText(`Score: ${totalScore}`, 10, 8);
                ctx.restore();

                // Draw per-level breakdowns (newest at top, old pushed down, dimmer as they go)
                if (window.levelScoreHistory && Array.isArray(window.levelScoreHistory) && window.levelScoreHistory.length > 0) {
                    ctx.save();
                    ctx.font = `bold ${scoreFontSize}px monospace`;
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'top';
                    let breakdownY = 8;
                    for (let i = 0; i < window.levelScoreHistory.length; i++) {
                        const entry = window.levelScoreHistory[window.levelScoreHistory.length - 1 - i]; // newest at top
                        ctx.globalAlpha = Math.max(0.25, 1.0 - (i * 0.18));
                        ctx.fillStyle = '#fff';
                        // Ensure text is on screen
                        ctx.fillText(entry, gameCanvas.width - 10, breakdownY);
                        breakdownY += 26;
                    }
                    ctx.restore();
                }

                // Draw the "HARD DIVISION" overlay if active
                if (gameStartedOverlayActive) {
                    const elapsed = now - gameStartedOverlayStartTime;
                    let opacity = 1;
                    let currentTitleFontSize;

                    // Phase 1: Zoom In
                    if (elapsed < OVERLAY_ZOOM_DURATION) {
                        const zoomProgress = elapsed / OVERLAY_ZOOM_DURATION;
                        const initialSize = Math.floor(gameCanvas.height * INITIAL_OVERLAY_FONT_FACTOR); // Use gameCanvas.height
                        const targetSize = Math.floor(gameCanvas.height * MAX_OVERLAY_FONT_FACTOR); // Use gameCanvas.height
                        currentTitleFontSize = initialSize + (targetSize - initialSize) * zoomProgress;
                        opacity = 1; // Full opacity during zoom
                    }
                    // Phase 2: Fade Out (starts after zoom)
                    else {
                        const fadeElapsed = elapsed - OVERLAY_ZOOM_DURATION;
                        const fadeProgress = Math.min(1, fadeElapsed / OVERLAY_FADE_DURATION);
                        opacity = 1 - fadeProgress;
                        currentTitleFontSize = Math.floor(gameCanvas.height * MAX_OVERLAY_FONT_FACTOR); // Hold max size during fade // Use gameCanvas.height
                    }

                    if (opacity <= 0) {
                        gameStartedOverlayActive = false; // Deactivate once fully faded
                    } else {
                        ctx.save();
                        ctx.globalAlpha = opacity;
                        ctx.fillStyle = '#FFD700'; // Gold color for the title
                        ctx.font = `${currentTitleFontSize}px VT323`; // Use dynamic font size
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Add shadow
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; // Black shadow, slightly transparent
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 5;
                        ctx.shadowOffsetY = 5;

                        ctx.fillText("HARD DIVISION", gameCanvas.width / 2, gameCanvas.height / 2 - gameCanvas.height * 0.05); // Use gameCanvas.width/height
                        ctx.restore();
                    }
                }

                // Removed the word bubble drawing logic from here as per user request.
                // Event messages will now only appear in the dialogue area on the left.

                // Draw the "PRESS R TO RESTART" message or its particles if game is over
                // This block now draws if gameOver OR if the restart animation is active
                if (gameOver || restartTextAnimationActive) {
                    if (restartTextAnimationActive) {
                        const elapsed = now - restartTextAnimationStartTime;
                        const progress = elapsed / RESTART_TEXT_EXPLOSION_DURATION;

                        if (progress >= 1) {
                            restartTextAnimationActive = false;
                            restartTextParticles = []; // Clear particles once animation is done
                        } else {
                            for (let i = restartTextParticles.length - 1; i >= 0; i--) {
                                const particle = restartTextParticles[i];
                                const particleProgress = (now - particle.startTime) / RESTART_TEXT_EXPLOSION_DURATION;

                                if (particleProgress >= 1) {
                                    continue;
                                }

                                const opacity = 1 - particleProgress;
                                const moveDistance = particle.initialSpeed * elapsed; // Use elapsed for continuous movement

                                const currentX = particle.startX + particle.dirX * moveDistance;
                                const currentY = particle.startY + particle.dirY * moveDistance;

                                ctx.save();
                                ctx.globalAlpha = opacity;
                                ctx.fillStyle = particle.color;
                                // Ensure font size consistency
                                ctx.font = `${Math.floor(dynamicTileSize * 0.8 * (1 - particleProgress * 0.5))}px VT323`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(particle.char, currentX, currentY);
                                ctx.restore();
                            }
                        }
                    } else if (gameOver) { // Only draw static text if game is over AND no animation is active
                        ctx.fillStyle = '#FFD700'; // Gold color for restart message
                        ctx.font = `${Math.floor(currentRenderTileSize * 0.8)}px VT323`; // Use currentRenderTileSize for scaling
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText("PRESS R TO RESTART", gameCanvas.width / 2, gameCanvas.height / 2 + currentRenderTileSize * 1.5); // Use gameCanvas.width/height
                    }
                }

            } catch (error) {
                console.error("Error in animation loop:", error);
                stopAnimationLoop(); // Stop the loop to prevent further errors
                handleGameOver(); // Attempt to gracefully end the game
            }
        }

        /**
         * Moves an entity (player or enemy) towards a target, considering obstacles.
         * @param {object} entity - The entity to move ({x, y}).
         * @param {number} targetX - The target X coordinate.
         * @param {number} targetY - The target Y coordinate.
         * @param {Array<object>} obstacles - An array of other entities (excluding the moving entity) to avoid.
         * @param {object|null} forbiddenTarget - An optional tile that the entity explicitly cannot move onto.
         * @returns {boolean} True if the entity moved, false otherwise.
         */
        function moveEntityTowardsTarget(entity, targetX, targetY, obstacles, forbiddenTarget = null) {
            // Validate entity position before attempting to move
            if (isNaN(entity.x) || isNaN(entity.y) || entity.x === null || entity.y === null) {
                console.error("Entity position is invalid. Cannot move.");
                return false;
            }

            const dxToTarget = targetX - entity.x;
            const dyToTarget = targetY - entity.y;

            let moveX = 0;
            let moveY = 0;

            // Prioritize movement along the axis with the greater distance
            if (Math.abs(dxToTarget) > Math.abs(dyToTarget)) {
                moveX = Math.sign(dxToTarget);
            } else {
                moveY = Math.sign(dyToTarget);
            }

            let newX = entity.x + moveX;
            let newY = entity.y + moveY;

            // Check if the primary move is valid
            if (newX < 0 || newX >= dynamicMapWidth || newY < 0 || newY >= dynamicMapHeight ||
                gameMap[newY][newX] === TILE_WALL ||
                obstacles.some(o => o.x === newX && o.y === newY) ||
                (forbiddenTarget && newX === forbiddenTarget.x && newY === forbiddenTarget.y)) {
                // If the primary move is blocked, try the other axis
                moveX = 0;
                moveY = 0;
                if (Math.abs(dxToTarget) > Math.abs(dyToTarget)) { // If X was primary, try Y
                    moveY = Math.sign(dyToTarget);
                } else { // If Y was primary, try X
                    moveX = Math.sign(dxToTarget);
                }
                newX = entity.x + moveX;
                newY = entity.y + moveY;
            }

            // Final check for the chosen move (either primary or secondary)
            if (newX >= 0 && newX < dynamicMapWidth && newY >= 0 && newY < dynamicMapHeight &&
                (gameMap[newY][newX] === TILE_FLOOR || gameMap[newY][newX] === TILE_STAIRS) &&
                !obstacles.some(o => o.x === newX && o.y === newY) &&
                !(forbiddenTarget && newX === forbiddenTarget.x && newY === forbiddenTarget.y)) {
                entity.x = newX;
                entity.y = newY;
                
                // Invalidate caches when entities move
                cacheValidationFrame++;
                invalidateSpatialIndex();
                
                // Increment steps taken for enemies if they are moving
                if (entity.totalDamageDealtByThisEnemy !== undefined && entity.stepsTakenByThisEnemy !== undefined) { // Check if it's an enemy
                    entity.stepsTakenByThisEnemy = entity.stepsTakenByThisEnemy + 1; // Explicit assignment
                }
                return true; // Movement successful
            }

            return false; // Movement failed
        }

        /**
         * Adds a damage text animation to the queue.
         * @param {number} x - X coordinate of the hit entity.
         * @param {number} y - Y coordinate of the hit entity.
         * @param {number} amount - Damage amount.
         * @param {string} color - Color of the damage text.
         * @param {number} dirX - X component of the direction vector for animation.
         * @param {number} dirY - Y component of the direction vector for animation.
         * @param {number} duration - Duration of the animation in milliseconds.
         * @param {number} delay - Delay before animation starts in milliseconds.
         */
        function addDamageAnimation(x, y, amount, color, dirX, dirY, duration = 1000, delay = 0) {
            activeDamageTextAnimations.push({
                x: x,
                y: y,
                amount: amount,
                color: VINTAGE_GREEN,
                dirX: dirX,
                dirY: dirY,
                startTime: performance.now(),
                duration: duration,
                delay: delay
            });
        }

        /**
         * Creates a single particle for an explosion animation.
         * @param {number} x - X coordinate of the particle's origin.
         * @param {number} y - Y coordinate of the particle's origin.
         * @param {string} color - Color of the particle.
         * @param {number} initialVelocityX - Initial horizontal velocity.
         * @param {number} initialVelocityY - Initial vertical velocity.
         * @param {number} duration - Duration of the particle's animation.
         * @param {number} fadeFactor - A factor to control how quickly the particle fades.
         * @returns {object} Particle object.
         */
        function createParticle(x, y, color, initialVelocityX, initialVelocityY, duration, fadeFactor) {
            return {
                x: x,
                y: y,
                color: color,
                initialVelocityX: initialVelocityX,
                initialVelocityY: initialVelocityY,
                startTime: performance.now(),
                duration: duration,
                fadeFactor: fadeFactor
            };
        }

        /**
         * Adds an explosion animation at a given tile.
         * @param {number} tileX - X coordinate of the tile.
         * @param {number} tileY - Y coordinate of the tile.
         * @param {string} color - Color of the particles.
         * @param {number} damageAmount - The damage that caused the explosion (for scaling).
         * @param {number} numParticles - Number of particles in the explosion.
         * @param {number} duration - Duration of the explosion animation in milliseconds.
         * @param {number} [spreadFactor=1] - Multiplier for particle spread.
         */
        function addExplosionAnimation(tileX, tileY, color, damageAmount, numParticles = 15, duration = 1500, spreadFactor = 1) {
            const scaledNumParticles = Math.max(5, Math.min(numParticles + (damageAmount * 1), 50)); // Cap at 50 for performance

            const explosion = {
                particles: [],
                startTime: performance.now(),
                duration: duration,
                damageAmount: damageAmount
            };

            for (let i = 0; i < scaledNumParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                // Scale speed by the provided spreadFactor
                const speed = (Math.random() * 1.0 + 0.1) * (dynamicTileSize / 150) * spreadFactor;
                const initialVelocityX = Math.cos(angle) * speed;
                const initialVelocityY = Math.sin(angle) * speed;
                const randomFadeFactor = Math.random() * 0.7 + 0.3;
                explosion.particles.push(createParticle(tileX, tileY, color, initialVelocityX, initialVelocityY, duration, randomFadeFactor));
            }
            activeExplosions.push(explosion);
        }

        /**
         * Handles game over state.
         */
        function handleGameOver() {
            console.log("Game Over triggered.");
            gameOver = true;
            stopAutomatedMovement();
            // Do not stop animation loop here, enemies need to move and explosion needs to play
            window.removeEventListener('keydown', handleKeyDown); // Temporarily remove player movement listener

            // Activate death animation effects
            deathAnimationActive = true;
            deathAnimationStartTime = performance.now();
            timeScale = DEATH_SLOW_MOTION_FACTOR; // Activate slow motion

            // Capture player's final color
            const playerHealthRatio = player.health / PLAYER_VISUAL_HEALTH_THRESHOLD;
            const finalPlayerColor = getHealthColor(FIXED_COLOR_PLAYER, player.health, PLAYER_VISUAL_HEALTH_THRESHOLD);

            // Player death animation: Explode and scatter numbers/symbols
            addExplosionAnimation(player.x, player.y, finalPlayerColor, player.health, PLAYER_DEATH_PARTICLE_COUNT, PLAYER_DEATH_EXPLOSION_DURATION, PLAYER_DEATH_PARTICLE_SPREAD_FACTOR);

            // Scatter player's "numbers" (health/damage dealt) and symbols as pickups
            let remainingValueToScatter = player.health;
            const scatterCount = Math.min(player.health + MATH_SYMBOLS.length, 50); // More particles for drama
            for (let i = 0; i < scatterCount; i++) {
                const randomOffsetX = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR; // Wider spread
                const randomOffsetY = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;

                let partContent;
                if (remainingValueToScatter > 0 && Math.random() < 0.7) { // Bias towards numbers initially
                    const value = Math.min(PLAYER_DEATH_PICKUP_VALUE_PER_CHUNK, remainingValueToScatter);
                    partContent = { type: 'number', value: value };
                    remainingValueToScatter = remainingValueToScatter - value; // Explicit assignment
                } else {
                    const symbol = MATH_SYMBOLS[getRandomInt(0, MATH_SYMBOLS.length - 1)];
                    partContent = { type: 'symbol', value: symbol };
                }

                staticDamageNumbers.push({
                    x: player.x,
                    y: player.y,
                    parts: [{ content: partContent, offsetX: randomOffsetX, offsetY: randomOffsetY }], // Changed 'amount' to 'content'
                    isEnemyDrop: false,
                    isPlayerRemains: true,
                    playerDeathColor: finalPlayerColor, // Store the player's death color with the remains
                    writhingOffsetAngle: Math.random() * Math.PI * 2, // Initial angle for writhing
                    writhingOffsetRadius: (Math.random() * 0.5 + 0.5) * dynamicTileSize * 0.1, // Small radius, slightly varied
                    writhingSpeed: (Math.random() * 0.0005 + 0.0002) // Very slow speed for subtle writhing
                });
            }
            // Ensure any remaining value is scattered as a final number if any
            if (remainingValueToScatter > 0) {
                const randomOffsetX = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;
                const randomOffsetY = (Math.random() - 0.5) * dynamicTileSize * PLAYER_DEATH_PARTICLE_SPREAD_FACTOR;
                staticDamageNumbers.push({
                    x: player.x,
                    y: player.y,
                    parts: [{ content: { type: 'number', value: remainingValueToScatter }, offsetX: randomOffsetX, offsetY: randomOffsetY }],
                    isEnemyDrop: false,
                    isPlayerRemains: true,
                    playerDeathColor: finalPlayerColor,
                    writhingOffsetAngle: Math.random() * Math.PI * 2,
                    writhingOffsetRadius: (Math.random() * 0.5 + 0.5) * dynamicTileSize * 0.1,
                    writhingSpeed: (Math.random() * 0.0005 + 0.0002)
                });
            }

            // Calculate final score and add to leaderboard
            let finalScore = 0;
            if (stepsTaken > 0) {
                const scoreMultiplier = Math.max(1, currentLevel * 0.5);
                // Reduced flowBonus weight from 100x to 20x to encourage exploration
                const flowBonus = Math.floor((totalDamageDealt / stepsTaken) * 20);
                const healthBonus = Math.floor(player.health * 5);
                const levelBonus = Math.floor((currentLevel - 1) * 200);
                // Add exploration bonus for steps taken (rewards strategic movement)
                const explorationBonus = Math.floor(stepsTaken * 2);
                finalScore = Math.floor((totalDamageDealt + flowBonus + healthBonus + levelBonus + explorationBonus) * scoreMultiplier);
            }
            
            // Update total player score for world progression
            totalPlayerScore = Math.max(totalPlayerScore, finalScore);
            localStorage.setItem('hardDivisionTotalScore', totalPlayerScore.toString());
            checkAndUnlockWorlds();
            
            // Score calculated but not saved to leaderboard

            // Start enemy swarm behavior (animation loop is already running)
            startEnemySwarm();

            // Re-add event listener for restart only
            window.addEventListener('keydown', handleRestartKeyDown);
        }

        /**
         * Handles the 'R' key press for restarting the game.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleRestartKeyDown(event) {
            if (gameOver && (event.key === 'r' || event.key === 'R')) {
                event.preventDefault();

                // Get the position and size of the "PRESS R TO RESTART" text
                const restartText = "PRESS R TO RESTART";
                // Use dynamicTileSize for font sizing to match the game's current scale
                const baseFontSize = Math.floor(dynamicTileSize * 0.8);
                ctx.font = `${baseFontSize}px VT323`;
                const textMetrics = ctx.measureText(restartText);
                const textWidth = textMetrics.width;
                const textHeight = baseFontSize; // Approximate height based on font size

                const textX = gameCanvas.width / 2;
                const textY = gameCanvas.height / 2 + dynamicTileSize * 1.5;

                // Generate particles for each character
                restartTextParticles = [];
                let currentTextX = textX - textWidth / 2; // Start X for the first character
                const charSpacing = textWidth / restartText.length; // Simple even spacing

                for (let i = 0; i < restartText.length; i++) {
                    const char = restartText[i];
                    const charX = currentTextX + charSpacing * i + charSpacing / 2; // Center of the character
                    const charY = textY;

                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 0.5 + 0.2) * (dynamicTileSize / 20); // Slower, more controlled spread
                    const dirX = Math.cos(angle);
                    const dirY = Math.sin(angle);
                    const fadeFactor = Math.random() * 0.7 + 0.3;

                    restartTextParticles.push({
                        char: char,
                        startX: charX,
                        startY: charY,
                        dirX: dirX,
                        dirY: dirY,
                        initialSpeed: speed,
                        fontSize: baseFontSize, // Use the calculated baseFontSize for consistency
                        color: '#FFD700', // Gold color for the text particles
                        startTime: performance.now(),
                        duration: RESTART_TEXT_EXPLOSION_DURATION,
                        fadeFactor: fadeFactor
                    });
                }

                restartTextAnimationActive = true;
                restartTextAnimationStartTime = performance.now();

                // Immediately start the game restart (which includes the zoom-out)
                restartGame();
            }
        }

        /**
         * Restarts the game.
         */
        function restartGame() {
            window.removeEventListener('keydown', handleRestartKeyDown); // Remove restart listener
            initGame(true, false); // Start a brand new game, no overlay on restart
            // The animation loop is already running, no need to restart it here.
        }

        /**
         * Initiates enemy swarm behavior after player death.
         */
        function startEnemySwarm() {
            // This function ensures enemies continuously move towards player remains.
            // The actual movement logic is within enemyTurn().
            console.log("Enemies starting swarm behavior.");
        }

        /**
         * Checks the player's current tile for any static health pickups and collects them.
         */
        function checkAndCollectPickups() {
            for (let i = staticDamageNumbers.length - 1; i >= 0; i--) {
                const staticNum = staticDamageNumbers[i];
                // Only collect non-player-remains pickups
                if (!staticNum.isPlayerRemains && getDistance(player, staticNum) <= DIRECT_PICKUP_RADIUS) {
                    let healthGained = 0;
                    staticNum.parts.forEach(part => {
                        healthGained = healthGained + part.content.value; // Explicit assignment
                        activePickupAnimations.push({
                            startX: staticNum.x,
                            startY: staticNum.y,
                            initialOffsetX: part.offsetX || 0,
                            initialOffsetY: part.offsetY || 0,
                            amount: part.content.value, // Pass value from content
                            color: VINTAGE_GREEN,
                            startTime: performance.now(),
                            duration: 300
                        });
                    });
                    player.health = player.health + healthGained; // Explicit assignment
                    totalPickupValueCollectedThisTurn = totalPickupValueCollectedThisTurn + healthGained; // Explicit assignment
                    player.healthAnimScale = 1.5;
                    player.healthAnimStartTime = performance.now();
                    staticDamageNumbers.splice(i, 1);
                }
            }
        }

        /**
         * Applies health loss to the player based on steps taken.
         * Interval and damage are both inversely proportional to current health.
         */
        function applyStepBasedHealthLoss() {
            // Calculate dynamic interval based on health
            const MIN_INTERVAL = 10;  // Minimum steps between health loss (when health is high)
            const MAX_INTERVAL = 37;  // Maximum steps between health loss (when health is low)
            
            let dynamicInterval;
            if (player.health <= 1) {
                dynamicInterval = MAX_INTERVAL; // Lowest health = longest interval
            } else {
                // Use inverse proportion: interval = MAX_INTERVAL / (health)
                // Clamp to minimum interval to prevent too-frequent health loss at high health
                dynamicInterval = Math.max(MIN_INTERVAL, Math.floor(MAX_INTERVAL / player.health));
            }

            if (stepsTaken > 0 && stepsTaken % dynamicInterval === 0) {
                // Always lose 10% of current health (rounded)
                let damage = Math.round(player.health * 0.1);
                if (damage < 1 && player.health > 0) {
                    damage = 1;
                } else if (player.health === 0) {
                    damage = 0;
                }

                if (damage > 0) {
                    player.health = player.health - damage;
                    hitsTaken = hitsTaken + 1;
                    hitsTakenThisTurn = hitsTakenThisTurn + 1;
                    playerTookDamageInCombatThisTurn = true;
                    const animDuration = Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damage - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE));
                    addDamageAnimation(player.x, player.y, damage, VINTAGE_GREEN, 0, -1, animDuration, 0);
                }

                // Sanity check for player health after health loss
                if (isNaN(player.health)) {
                    console.error("Player health became NaN after step-based health loss! Forcing game over.");
                    player.health = 0;
                }

                if (player.health <= 0) {
                    console.log(`PLAYER DEATH from step-based loss: Health=${player.health}, StepsTaken=${stepsTaken}, Level=${currentLevel}, Damage=${damage}`);
                    player.health = 0; // Ensure health doesn't go negative for display
                    handleGameOver();
                }
            }
        }

        /**
         * Moves the player if the target tile is a floor or stairs.
         * Handles combat if the target tile is occupied by an enemy.
         * @param {number} dx - Change in X coordinate.
         * @param {number} dy - Change in Y coordinate.
         * @returns {boolean} True if combat occurred, false otherwise.
         */
        function movePlayer(dx, dy) {
            if (gameOver) return false;

            // Validate player position before attempting to move
            if (isNaN(player.x) || isNaN(player.y) || player.x === null || player.y === null) {
                console.error("Player position is invalid. Cannot move.");
                return false;
            }

            const newX = player.x + dx;
            const newY = player.y + dy;

            if (newX < 0 || newX >= dynamicMapWidth || newY < 0 || newY >= dynamicMapHeight) {
                return false;
            }

            const collidedEnemyIndex = enemies.findIndex(e => e.x === newX && e.y === newY);

            if (collidedEnemyIndex !== -1) {
                const attackedEnemy = enemies[collidedEnemyIndex];
                const enemyHealthBeforeHit = attackedEnemy.health; // Store health before hit
                const enemyInitialHealth = attackedEnemy.initialHealth; // Store initial health of this enemy

                let playerAttacksFirst = Math.random() < 0.5;

                let combatActionOccurred = false;
                let damageDealtToEnemy = 0; // Declare damageDealtToEnemy here
                let totalDamageDealtToEnemy = 0; // Track total damage dealt to enemy in this combat
                let totalDamageDealtToPlayer = 0; // Track total damage dealt to player in this combat

                combatOccurredThisTurn = true; // Mark that combat occurred this turn

                if (playerAttacksFirst) {
                    // Player attacks enemy
                    player.thrustAnimActive = true;
                    player.thrustAnimStartTime = performance.now();
                    player.thrustAnimDirectionX = dx;
                    player.thrustAnimDirectionY = dy;
                    damageDealtToEnemy = calculateSimpleDamage(player.health); // Simple predictable damage
                    console.log('Combat: Player attacks enemy -', 'Player health:', player.health, 'Enemy health:', attackedEnemy.health, 'Damage dealt:', damageDealtToEnemy);
                    
                    // Critical hits removed for fully predictable combat
                    eventFlags.criticalStrike = false;

                    damageDealtToEnemy = Math.min(damageDealtToEnemy, attackedEnemy.health);
                    player.thrustAnimMagnitude = Math.min(1, damageDealtToEnemy / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE); // Normalize damage for thrust magnitude

                    attackedEnemy.health = attackedEnemy.health - damageDealtToEnemy; // Explicit assignment
                    // MODIFIED: Enemy flow increases when attacked by player
                    attackedEnemy.totalDamageTakenByThisEnemy = (attackedEnemy.totalDamageTakenByThisEnemy || 0) + damageDealtToEnemy;
                    
                    hitsDealt = hitsDealt + 1; // Explicit assignment
                    totalDamageDealt = totalDamageDealt + damageDealtToEnemy; // Explicit assignment
                    damageDealtThisTurn = damageDealtThisTurn + damageDealtToEnemy; // Explicit assignment
                    addDamageAnimation(attackedEnemy.x, attackedEnemy.y, damageDealtToEnemy, VINTAGE_GREEN, dx, dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToEnemy - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));
                    combatActionOccurred = true;

                    if (attackedEnemy.health > 0) {
                        // Enemy counter-attacks player
                        attackedEnemy.thrustAnimActive = true;
                        attackedEnemy.thrustAnimStartTime = performance.now();
                        attackedEnemy.thrustAnimDirectionX = -dx; // Attack back towards player
                        attackedEnemy.thrustAnimDirectionY = -dy;
                        // Use enemy.totalDamageTakenByThisEnemy for enemy flow.
                        // If no damage taken yet, use enemy.flowLevel for initial flow.
                        let damageDealtToPlayer = calculateSimpleDamage(attackedEnemy.health); // Simple predictable damage
                        
                        // Critical hits removed for fully predictable combat
                        
                        damageDealtToPlayer = Math.min(damageDealtToPlayer, player.health);
                        totalDamageDealtToPlayer = totalDamageDealtToPlayer + damageDealtToPlayer; // Track damage
                        attackedEnemy.thrustAnimMagnitude = Math.min(1, damageDealtToPlayer / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);
                        attackedEnemy.totalDamageDealtByThisEnemy = attackedEnemy.totalDamageDealtByThisEnemy + damageDealtToPlayer; // Explicit assignment

                        player.health = player.health - damageDealtToPlayer; // Explicit assignment
                        hitsTaken = hitsTaken + 1; // Explicit assignment
                        hitsTakenThisTurn = hitsTakenThisTurn + 1; // Explicit assignment
                        if (damageDealtToPlayer > 0) {
                            playerTookDamageInCombatThisTurn = true; // Player took damage in combat
                        }
                        addDamageAnimation(player.x, player.y, damageDealtToPlayer, VINTAGE_GREEN, -dx, -dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToPlayer - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)), 200);
                    }
                } else {
                    // Enemy attacks player first
                    attackedEnemy.thrustAnimActive = true;
                    attackedEnemy.thrustAnimStartTime = performance.now();
                    attackedEnemy.thrustAnimDirectionX = -dx;
                    attackedEnemy.thrustAnimDirectionY = -dy;
                    // Use enemy.totalDamageTakenByThisEnemy for enemy flow.
                    // If no damage taken yet, use enemy.flowLevel for initial flow.
                    let damageDealtToPlayer = calculateSimpleDamage(attackedEnemy.health); // Simple predictable damage
                    
                    // Critical hits removed for fully predictable combat
                    
                    damageDealtToPlayer = Math.min(damageDealtToPlayer, player.health);
                    attackedEnemy.thrustAnimMagnitude = Math.min(1, damageDealtToPlayer / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);
                    attackedEnemy.totalDamageDealtByThisEnemy = attackedEnemy.totalDamageDealtByThisEnemy + damageDealtToPlayer; // Explicit assignment

                    player.health = player.health - damageDealtToPlayer; // Explicit assignment
                    hitsTaken = hitsTaken + 1; // Explicit assignment
                    hitsTakenThisTurn = hitsTakenThisTurn + 1; // Explicit assignment
                    if (damageDealtToPlayer > 0) {
                        playerTookDamageInCombatThisTurn = true; // Player took damage in combat
                    }
                    addDamageAnimation(player.x, player.y, damageDealtToPlayer, VINTAGE_GREEN, -dx, -dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToPlayer - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));
                    combatActionOccurred = true;

                    if (player.health > 0) {
                        // Player counter-attacks enemy
                        player.thrustAnimActive = true;
                        player.thrustAnimStartTime = performance.now();
                        player.thrustAnimDirectionX = dx;
                        player.thrustAnimDirectionY = dy;
                        damageDealtToEnemy = calculateSimpleDamage(player.health); // Simple predictable damage
                    
                    // Critical hits removed for fully predictable combat
                    eventFlags.criticalStrike = false;

                    damageDealtToEnemy = Math.min(damageDealtToEnemy, attackedEnemy.health);
                    totalDamageDealtToEnemy = totalDamageDealtToEnemy + damageDealtToEnemy; // Track damage
                    player.thrustAnimMagnitude = Math.min(1, damageDealtToEnemy / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE); // Normalize damage for thrust magnitude

                    attackedEnemy.health = attackedEnemy.health - damageDealtToEnemy; // Explicit assignment
                        // MODIFIED: Enemy flow increases when attacked by player
                        attackedEnemy.totalDamageTakenByThisEnemy = (attackedEnemy.totalDamageTakenByThisEnemy || 0) + damageDealtToEnemy;
                        
                        hitsDealt = hitsDealt + 1; // Explicit assignment
                        totalDamageDealt = totalDamageDealt + damageDealtToEnemy; // Explicit assignment
                        damageDealtThisTurn = damageDealtThisTurn + damageDealtToEnemy; // Explicit assignment
                        addDamageAnimation(attackedEnemy.x, attackedEnemy.y, damageDealtToEnemy, VINTAGE_GREEN, dx, dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToEnemy - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)), 200);
                    }
                }

                if (attackedEnemy.health <= 0) {
                    console.log('Enemy died:', attackedEnemy.name, 'Health:', attackedEnemy.health, 'Damage dealt:', damageDealtToEnemy);
                    // Calculate spread factor for explosion based on damage dealt
                    const explosionSpread = ENEMY_DEATH_EXPLOSION_BASE_SPREAD + (damageDealtToEnemy * ENEMY_DEATH_EXPLOSION_DAMAGE_SPREAD_MULTIPLIER);
                    addExplosionAnimation(attackedEnemy.x, attackedEnemy.y, FIXED_COLOR_ENEMY, enemyHealthBeforeHit, undefined, undefined, explosionSpread); // Pass explosionSpread

                    // MODIFIED: "One-Shot Kill" detection - only if enemy went from initial health to 0
                    if (attackedEnemy.initialHealth === enemyHealthBeforeHit && attackedEnemy.health <= 0) {
                        const isMajor = enemyHealthBeforeHit >= ONE_SHOT_MAJOR_HEALTH;
                        const logMessage = `${player.name} eliminated ${attackedEnemy.name} (HP: ${enemyHealthBeforeHit}) in a single devastating strike`;
                        
                        addEventMessage("One-Shot Kill!", isMajor, logMessage);
                        eventFlags.oneShotKill = true;
                    } else {
                        eventFlags.oneShotKill = false;
                    }

                    // Calculate pickup scatter magnitude based on damage dealt
                    const pickupScatterMagnitude = PICKUP_SCATTER_BASE_SPREAD + (damageDealtToEnemy * PICKUP_SCATTER_DAMAGE_MULTIPLIER);

                    // Enemy drops exactly the amount of health it had before the final hit
                    let remainingDroppedHealth = enemyHealthBeforeHit;

                    // Denominations for splitting
                    const denominations = [10, 5, 1]; // Prioritize larger denominations

                    while (remainingDroppedHealth > 0) {
                        // Calculate scatter position, ensuring it stays within playable area
                        let scatterX, scatterY;
                        let attempts = 0;
                        const maxAttempts = 20;
                        
                        do {
                            const randomOffsetX = (Math.random() - 0.5) * 2.0 * pickupScatterMagnitude; // Scatter in tile units
                            const randomOffsetY = (Math.random() - 0.5) * 2.0 * pickupScatterMagnitude;
                            
                            scatterX = Math.round(attackedEnemy.x + randomOffsetX);
                            scatterY = Math.round(attackedEnemy.y + randomOffsetY);
                            attempts++;
                        } while (attempts < maxAttempts && (
                            scatterX < 0 || scatterX >= dynamicMapWidth || 
                            scatterY < 0 || scatterY >= dynamicMapHeight ||
                            gameMap[scatterY][scatterX] !== TILE_FLOOR
                        ));
                        
                        // If no valid position found, place on enemy's tile
                        if (scatterX < 0 || scatterX >= dynamicMapWidth || scatterY < 0 || scatterY >= dynamicMapHeight ||
                            gameMap[scatterY][scatterX] !== TILE_FLOOR) {
                            scatterX = attackedEnemy.x;
                            scatterY = attackedEnemy.y;
                        }

                        let valueToDrop = 0;
                        for (const denom of denominations) {
                            if (remainingDroppedHealth >= denom) {
                                valueToDrop = denom;
                                break;
                            }
                        }
                        if (valueToDrop === 0 && remainingDroppedHealth > 0) {
                            valueToDrop = remainingDroppedHealth; // Drop remaining as a 1 if it's less than smallest denom
                        }

                        if (valueToDrop > 0) {
                            staticDamageNumbers.push({
                                x: scatterX,
                                y: scatterY,
                                parts: [{ content: { type: 'number', value: valueToDrop }, offsetX: 0, offsetY: 0 }], // No sub-tile offset needed
                                isEnemyDrop: true
                            });
                            remainingDroppedHealth -= valueToDrop;
                        } else {
                            break; // Should not happen if remainingDroppedHealth > 0
                        }
                    }

                    // Add activity log entry for the kill
                    addActivityLogEntry(player, attackedEnemy, totalDamageDealtToEnemy, totalDamageDealtToPlayer);
                    
                    // Track killed enemy for events
                    killedEnemiesThisTurn.push(attackedEnemy.name);
                    
                    enemies.splice(collidedEnemyIndex, 1);
                    enemiesKilledThisTurn = enemiesKilledThisTurn + 1; // Explicit assignment
                }

                // Sanity check for player health after combat
                if (isNaN(player.health)) {
                    console.error("Player health became NaN during combat! Forcing game over.");
                    player.health = 0; // Set to 0 to trigger game over
                }

                if (player.health <= 0) {
                    console.log("DEBUG: Player died in combat! Health:", player.health, "Level:", player.level);
                    player.health = 0; // Ensure health doesn't go negative for display
                    handleGameOver();
                }
                // Always return true if combat occurred, regardless of outcome
                return true;
            }

            const obstaclesForPlayer = enemies;
            const playerMoved = moveEntityTowardsTarget(player, newX, newY, obstaclesForPlayer);

            if (playerMoved) {
                stepsTaken = stepsTaken + 1; // Explicit assignment
                // Mark current tile as visited for "Map Explorer"
                if (visitedTiles[player.y] && visitedTiles[player.y][player.x] !== undefined) {
                    visitedTiles[player.y][player.x] = true;
                }
                applyStepBasedHealthLoss();
                checkAndCollectPickups(); // Check for and collect pickups after moving

                // Check for remote collection
                if (key && !key.collected && player.x === key.x && player.y === key.y) {
                    // Start triangle flying animation
                    triangleFlyActive = true;
                    triangleFlyStartTime = performance.now();
                    triangleFlyStartPos = { x: key.x, y: key.y };
                    triangleFlyEndPos = { x: stairs.x, y: stairs.y };
                    
                    key.collected = true;
                    console.log("Remote control collected!");
                    
                    // Start door opening animation after a short delay
                    doorAnimTimeoutId = setTimeout(() => {
                        doorAnimActive = true;
                        doorAnimStartTime = performance.now();
                        doorAnimTimeoutId = null; // Clear the timeout ID once it executes
                    }, triangleFlyDuration - 200); // Start door animation 200ms before triangle finishes
                }

                if (player.x === stairs.x && player.y === stairs.y) {
                    if (key && key.collected) {
                        nextLevel();
                    } else {
                        console.log("You need to find the remote control first!");
                        // Start door shake animation
                        doorShakeActive = true;
                        doorShakeStartTime = performance.now();
                    }
                }
                // Enemy turn is now called after player moves, regardless of combat
                enemyTurn();
                return false;
            }
            return false;
        }

        /**
         * Handles enemy turns. Each enemy moves based on its assigned role.
         */
        function enemyTurn() {
            // If game is over, enemies only swarm player remains
            if (gameOver) {
                enemies.forEach(enemy => {
                    const obstaclesForThisEnemy = enemies.filter(e => e !== enemy); // Enemies don't block each other if player is dead

                    // Find the closest player remains pickup
                    const closestPlayerRemains = getClosestEntity(staticDamageNumbers.filter(s => s.isPlayerRemains), enemy);

                    if (closestPlayerRemains) {
                        // Move towards the closest player remains
                        const moved = moveEntityTowardsTarget(enemy, closestPlayerRemains.x, closestPlayerRemains.y, obstaclesForThisEnemy, null);

                        // If enemy reached the remains, "eat" them
                        if (moved && enemy.x === closestPlayerRemains.x && enemy.y === closestPlayerRemains.y) {
                            const index = staticDamageNumbers.indexOf(closestPlayerRemains);
                            if (index > -1) {
                                staticDamageNumbers.splice(index, 1);
                                console.log(`Enemy ate player remains at (${closestPlayerRemains.x}, ${closestPlayerRemains.y})`);
                                // Increase enemy health by the amount of the eaten remains, only if it's a number
                                if (closestPlayerRemains.parts[0].content.type === 'number') {
                                    enemy.health = enemy.health + closestPlayerRemains.parts[0].content.value; // Explicit assignment
                                }
                            }
                        }
                    } else {
                        // If no more player remains, enemies can just wander or stay put
                        // For now, they'll just stand still if no remains are left.
                        // Could implement a random wander here if desired.
                    }
                });
                checkNotableEvents(); // Check events even if game over, for enemy swarm behavior
                // Reset per-turn stats after checkNotableEvents
                enemiesKilledThisTurn = 0;
                killedEnemiesThisTurn = []; // Reset killed enemies tracking
                damageDealtThisTurn = 0;
                hitsTakenThisTurn = 0;
                totalPickupValueCollectedThisTurn = 0;
                combatOccurredThisTurn = false; // Reset for next turn
                playerTookDamageInCombatThisTurn = false; // Reset for next turn
                return; // Skip normal enemy turn logic if game over
            }

            const HUNTER_MOVE_CHANCE = 0.8;
            const GUARD_PATROL_RADIUS = 5;
            const GUARD_MOVE_CHANCE = 0.5;
            const TRACKER_AGGRO_RADIUS = 8;
            const GLOBAL_STOP_CHANCE = 0.2; // 20% chance for any enemy to stop

            enemies.forEach(enemy => {
                // Apply global random stop chance before any movement logic
                if (Math.random() < GLOBAL_STOP_CHANCE) {
                    // Enemy decided to stop this turn
                    return;
                }

                let enemyAttackedThisTurn = false; // Flag for this enemy's turn

                // Check for unprovoked attack if player is adjacent (cardinal directions only, matching player attack rules)
                const dx_check = Math.abs(player.x - enemy.x);
                const dy_check = Math.abs(player.y - enemy.y);
                const isPlayerAdjacent = (dx_check <= 1 && dy_check <= 1) && (dx_check + dy_check === 1); // Only cardinal directions
                if (isPlayerAdjacent) {
                    // Use enemy.totalDamageTakenByThisEnemy for enemy flow.
                    // If no damage taken yet, use enemy.flowLevel for initial flow.
                    // Simplified: 30% chance for enemy to attack when adjacent
                    if (Math.random() < 0.3) {
                        // Enemy attacks unprovoked
                        enemy.thrustAnimActive = true;
                        enemy.thrustAnimStartTime = performance.now();
                        let dx = player.x - enemy.x; // Change to let
                        let dy = player.y - enemy.y; // Change to let
                        // Ensure attacks are cardinal only
                        if (Math.abs(dx) > 0 && Math.abs(dy) > 0) { // If diagonal, pick one axis
                            if (Math.random() < 0.5) dy = 0;
                            else dx = 0;
                        }

                        enemy.thrustAnimDirectionX = dx;
                        enemy.thrustAnimDirectionY = dy;

                        let damageDealtToPlayer = calculateSimpleDamage(enemy.health); // Simple predictable damage
                        
                        // Critical hits removed for fully predictable combat
                        
                        damageDealtToPlayer = Math.min(damageDealtToPlayer, player.health);
                        enemy.thrustAnimMagnitude = Math.min(1, damageDealtToPlayer / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE);
                        enemy.totalDamageDealtByThisEnemy = enemy.totalDamageDealtByThisEnemy + damageDealtToPlayer; // Explicit assignment

                        player.health = player.health - damageDealtToPlayer; // Explicit assignment
                        hitsTaken = hitsTaken + 1; // Explicit assignment
                        hitsTakenThisTurn = hitsTakenThisTurn + 1; // Explicit assignment
                        if (damageDealtToPlayer > 0) {
                            playerTookDamageInCombatThisTurn = true; // Player took damage in combat
                        }
                        addDamageAnimation(player.x, player.y, damageDealtToPlayer, VINTAGE_GREEN, dx, dy, Math.min(MAX_DAMAGE_ANIM_DURATION, MIN_DAMAGE_ANIM_DURATION + (damageDealtToPlayer - 1) * ((MAX_DAMAGE_ANIM_DURATION - MIN_DAMAGE_ANIM_DURATION) / MAX_DAMAGE_VALUE_FOR_ANIM_SCALE)));

                        // Sanity check for player health after combat
                        if (isNaN(player.health)) {
                            console.error("Player health became NaN during enemy unprovoked attack! Forcing game over.");
                            player.health = 0;
                        }
                        if (player.health <= 0) {
                            console.log("DEBUG: Player died in enemy unprovoked attack! Health:", player.health, "Level:", player.level);
                            player.health = 0;
                            handleGameOver();
                            return; // Stop further enemy turns if game over
                        }
                        enemyAttackedThisTurn = true;
                    }
                }

                if (!enemyAttackedThisTurn) { // Only move if no unprovoked attack occurred
                    const obstaclesForThisEnemy = enemies.filter(e => e !== enemy).concat(player);
                    let moved = false; // Flag to track if enemy successfully moved

                    // New: Check enemy's flowLevel for following chance
                    // MODIFIED: Enemy flow is now based on totalDamageTakenByThisEnemy
                    if (Math.random() < (enemy.totalDamageTakenByThisEnemy > 0 ? enemy.totalDamageTakenByThisEnemy / (enemy.stepsTakenByThisEnemy || 1) : 0)) { // If random number is less than flowLevel, enemy follows
                        moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                    } else { // Otherwise, enemy performs its role-based movement
                        if (enemy.role === 'hunter') {
                            // Hunters always try to move towards the player if not following by flow
                            moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                        } else if (enemy.role === 'guard') {
                            if (stairs && stairs.x !== undefined && stairs.y !== undefined) {
                                const distToStairs = getDistance(enemy, stairs);

                                if (distToStairs > GUARD_PATROL_RADIUS) {
                                    moved = moveEntityTowardsTarget(enemy, stairs.x, stairs.y, obstaclesForThisEnemy, stairs);
                                } else {
                                    if (Math.random() < GUARD_MOVE_CHANCE) { // Guard-specific stop chance
                                        // Only cardinal directions for guard's random movement
                                        const cardinalDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                                        let bestMove = null;
                                        let minCombinedDistance = Infinity;

                                        for (const [dx, dy] of cardinalDirections) { // Iterate over cardinal directions
                                            const newX = enemy.x + dx;
                                            const newY = enemy.y + dy;

                                            if (newX >= 0 && newX < dynamicMapWidth && newY >= 0 && newY < dynamicMapHeight &&
                                                (gameMap[newY][newX] === TILE_FLOOR || gameMap[newY][newX] === TILE_STAIRS) && // Move onto floor or stairs tiles
                                                !(newX === player.x && newY === player.y) &&
                                                !obstaclesForThisEnemy.some(o => o.x === newX && o.y === newY) &&
                                                (stairs && stairs.x !== undefined && stairs.y !== undefined && getDistance({x: newX, y: newY}, stairs) <= GUARD_PATROL_RADIUS + 1)) { // Allow movement to stairs

                                                const distToPlayer = getDistance({x: newX, y: newY}, player);
                                                const distToStairsFromNewPos = getDistance({x: newX, y: newY}, stairs);

                                                const combinedDistance = distToPlayer + distToStairsFromNewPos;

                                                if (combinedDistance < minCombinedDistance) {
                                                    minCombinedDistance = combinedDistance;
                                                    bestMove = {x: newX, y: newY};
                                                }
                                            }
                                        }

                                        if (bestMove) {
                                            enemy.x = bestMove.x;
                                            enemy.y = bestMove.y;
                                            moved = true; // Mark as moved
                                        }
                                    }
                                }
                            } else {
                                moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                            }
                        } else if (enemy.role === 'tracker') {
                            const distToPlayer = getDistance(enemy, player);
                            if (distToPlayer <= TRACKER_AGGRO_RADIUS) {
                                moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                            } else {
                                if (stairs && stairs.x !== undefined && stairs.y !== undefined) {
                                    moved = moveEntityTowardsTarget(enemy, stairs.x, stairs.y, obstaclesForThisEnemy, stairs);
                                } else {
                                    moved = moveEntityTowardsTarget(enemy, player.x, player.y, obstaclesForThisEnemy, stairs);
                                }
                            }
                        }
                    }
                }
            });

            checkNotableEvents(); // Check events after all entities have moved
            // Reset per-turn stats
            enemiesKilledThisTurn = 0;
            killedEnemiesThisTurn = []; // Reset killed enemies tracking
            damageDealtThisTurn = 0;
            hitsTakenThisTurn = 0;
            combatOccurredThisTurn = false; // Reset for next turn
            playerTookDamageInCombatThisTurn = false; // Reset for next turn
            totalPickupValueCollectedThisTurn = 0;
        }

        /**
         * Adds an event message to be displayed on screen.
         * @param {string} text - The text of the event message.
         * @param {boolean} isMajor - Whether this is a major event that should be logged.
         * @param {string} logMessage - Detailed message for the activity log (if major).
         */
        function addEventMessage(text, isMajor = false, logMessage = null) {
            // Only add if not already active or recently shown (simple check for now)
            // Could add more sophisticated cooldowns per event type if needed
            if (!activeEventMessages.some(msg => msg.text === text)) {
                activeEventMessages.push({
                    text: text,
                    startTime: performance.now(),
                    duration: EVENT_TEXT_DURATION
                });
                
                // Only show truly major/notable events in the message area
                // Minor events are filtered out to reduce message spam
                if (isMajor && logMessage) {
                    addMajorEventMessage(logMessage);
                }
                // Note: Regular events no longer appear as dialogue to reduce spam
                // They still appear as brief event titles above the player
            }
        }

        /**
         * Adds a major event message to the message area with warning styling.
         * @param {string} message - The detailed message to display.
         */
        function addMajorEventMessage(message) {
            // Create a small dialogue box instead of long message
            showSmallDialogue(message);
        }
        
        function showSmallDialogue(message) {
            // Messages disabled for now
            return;
        }
        
        function makeConcise(message) {
            console.log('DEBUG: Processing message:', message);
            
            // Handle specific achievement patterns from actual game messages
            if (message.includes('FLAWLESS VICTORY')) return 'FLAWLESS!';
            if (message.includes('MASSACRE')) return 'MASSACRE!';
            if (message.includes('BERSERKER')) return 'BERSERKER!';
            if (message.includes('GLASS CANNON')) return 'GLASS CANNON!';
            if (message.includes('LAST STAND')) return 'LAST STAND!';
            if (message.includes('HEADHUNTER')) return 'HEADHUNTER!';
            if (message.includes('NARROW ESCAPE')) return 'NARROW ESCAPE!';
            if (message.includes('DESPERATION')) return 'DESPERATION!';
            if (message.includes('GREEDY COLLECTOR')) return 'COLLECTOR!';
            if (message.includes('RESOURCE HOARDER')) return 'HOARDER!';
            if (message.includes('SPEED RUNNER')) return 'SPEED!';
            if (message.includes('CARTOGRAPHER')) return 'EXPLORER!';
            
            // World transitions
            if (message.includes('ENTERED')) {
                const worldMatch = message.match(/ENTERED (.+?)!/);
                if (worldMatch) return `→ ${worldMatch[1]}`;
            }
            
            // Enemy defeats - look for "defeated" pattern in player messages
            if (message.includes('defeated')) {
                const match = message.match(/defeated (.+?)!/);
                if (match) {
                    const enemyName = match[1].trim();
                    return `✗ ${enemyName}`;
                }
            }
            
            // If it contains HTML styling, extract plain text and look for enemy name
            if (message.includes('<span') || message.includes('background')) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = message;
                const plainText = tempDiv.textContent || tempDiv.innerText || '';
                
                // Look for "defeated EnemyName" pattern in plain text
                const defeatMatch = plainText.match(/defeated (.+?)(?:\s|$|!)/);
                if (defeatMatch) {
                    return `✗ ${defeatMatch[1].trim()}`;
                }
                
                // Extract last meaningful word as enemy name
                const words = plainText.trim().split(/\s+/).filter(word => word && word !== '');
                if (words.length >= 1) {
                    return `✗ ${words[words.length - 1]}`;
                }
            }
            
            // Fallback: extract key words from clean message
            const cleanMessage = message.replace(/<[^>]*>/g, '').trim();
            const words = cleanMessage.split(/\s+/).filter(word => word.length > 2);
            if (words.length >= 2) {
                // Look for achievement names in the message
                const achievementWords = words.filter(word => 
                    word.toUpperCase().match(/MASSACRE|BERSERKER|FLAWLESS|ESCAPE|DESPERATION|COLLECTOR/));
                if (achievementWords.length > 0) {
                    return achievementWords[0].toUpperCase() + '!';
                }
            }
            
            return words.slice(0, 2).join(' ').toUpperCase();
        }

        /**
         * Updates the opacity of all messages to create a gradient effect.
         * Newer messages (at the top) are more opaque, older ones fade out.
         */
        function updateMessageOpacity() {
            const messages = messageArea.children;
            for (let i = 0; i < messages.length; i++) {
                const opacity = Math.max(0.1, 1 - (i * 0.15)); // Each message is 15% more transparent
                messages[i].style.opacity = opacity;
            }
        }

        /**
         * Adds a new line of player dialogue to the dialogue area.
         * Function removed temporarily
         */
        function addPlayerDialogue(statusText) {
            // Dialogue system temporarily removed
            return;
        }

        /**
         * Emergency teleport function - teleports player to random empty tile but costs half their health
         */
        function emergencyTeleport() {
            if (gameOver) return;

            // Check if player has enough health to use teleport (need more than 1 health)
            if (player.health <= 1) {
                console.log("Not enough health to use emergency teleport!");
                addEventMessage("Not enough health to teleport!", false, `${player.name} needs more than 1 health to use emergency teleport`);
                return;
            }

            // Find all empty floor tiles
            const emptyTiles = [];
            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (gameMap[y][x] === TILE_FLOOR) {
                        // Check if tile is not occupied by an enemy
                        const isOccupied = enemies.some(enemy => enemy.x === x && enemy.y === y);
                        // Don't teleport to current position
                        const isCurrentPosition = (x === player.x && y === player.y);
                        // Don't teleport to stairs or key position
                        const isStairs = (stairs.x === x && stairs.y === y);
                        const isKey = (key && !key.collected && key.x === x && key.y === y);
                        
                        if (!isOccupied && !isCurrentPosition && !isStairs && !isKey) {
                            emptyTiles.push({ x, y });
                        }
                    }
                }
            }

            if (emptyTiles.length === 0) {
                console.log("No safe teleport locations available!");
                addEventMessage("No safe teleport locations!", false, `${player.name} cannot find a safe place to teleport`);
                return;
            }

            // Calculate health cost (half of current health, rounded up, minimum 1)
            const healthCost = Math.max(1, Math.ceil(player.health / 2));
            const oldHealth = player.health;
            const oldX = player.x;
            const oldY = player.y;

            // Apply health cost
            player.health -= healthCost;
            hitsTaken += 1; // Count as taking a hit for statistics

            // Pick random empty tile
            const randomTile = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
            
            // Start teleport animation
            teleportStartPos = { x: oldX, y: oldY };
            teleportEndPos = { x: randomTile.x, y: randomTile.y };
            teleportAnimActive = true;
            teleportAnimStartTime = performance.now();
            
            player.x = randomTile.x;
            player.y = randomTile.y;

            // Mark new tile as visited
            if (!visitedTiles[player.y]) visitedTiles[player.y] = [];
            visitedTiles[player.y][player.x] = true;

            // Trigger health animation
            player.healthAnimScale = 1.5;
            player.healthAnimStartTime = performance.now();

            // Add visual feedback
            addEventMessage("Emergency Teleport!", true, `${player.name} teleported from (${oldX}, ${oldY}) to (${player.x}, ${player.y}) at the cost of ${healthCost} health`);
            
            // Add damage animation at old position to show the cost
            addDamageAnimation(oldX, oldY, -healthCost, '#FF4444', 0, -1, 1500);

            // Add pickup animation at new position to show successful teleport
            addPickupAnimation(player.x, player.y, "TELEPORT", '#00FFFF', 1500);

            console.log(`Emergency teleport: ${player.name} lost ${healthCost} health (${oldHealth} -> ${player.health}) and teleported to (${player.x}, ${player.y})`);

            // Enemy turn happens after teleport
            enemyTurn();
        }

        /**
         * Counts the number of visited tiles in the `visitedTiles` grid.
         * @returns {number} The count of visited tiles.
         */
        function countVisitedTiles() {
            let count = 0;
            for (let y = 0; y < dynamicMapHeight; y++) {
                for (let x = 0; x < dynamicMapWidth; x++) {
                    if (visitedTiles[y] && visitedTiles[y][x]) {
                        count++;
                    }
                }
            }
            return count;
        }

        /**
         * Checks for notable game events based on current state and history.
         */
        function checkNotableEvents() {
            // 1. Store current state in history
            gameHistory.push({
                stepsTaken: stepsTaken,
                playerHealth: player.health,
                enemiesCount: enemies.length,
                hitsTaken: hitsTaken,
                totalDamageDealt: totalDamageDealt,
                playerX: player.x,
                playerY: player.y,
                enemiesPositions: enemies.map(e => ({ x: e.x, y: e.y, health: e.health, name: e.name })),
                pickupsOnMap: staticDamageNumbers.filter(s => !s.isPlayerRemains).map(p => ({ x: p.x, y: p.y, value: p.parts[0].content.value })),
                enemiesKilledThisTurn: enemiesKilledThisTurn,
                killedEnemyNames: [...killedEnemiesThisTurn],
                damageDealtThisTurn: damageDealtThisTurn,
                hitsTakenThisTurn: hitsTakenThisTurn,
                totalPickupValueCollectedThisTurn: totalPickupValueCollectedThisTurn,
                visitedTilesCount: countVisitedTiles(),
                combatOccurredThisTurn: combatOccurredThisTurn,
                playerTookDamageInCombatThisTurn: playerTookDamageInCombatThisTurn,
                currentLevel: currentLevel,
                playerFlow: stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0
            });

            if (gameHistory.length > HISTORY_LENGTH) {
                gameHistory.shift();
            }

            const currentTurn = gameHistory[gameHistory.length - 1];
            const previousTurn = gameHistory.length > 1 ? gameHistory[gameHistory.length - 2] : null;

            // === COMBAT EVENTS - OFFENSIVE ===
            
            // Massacre Event
            let enemiesKilledRecently = 0;
            for (let i = Math.max(0, gameHistory.length - 5); i < gameHistory.length; i++) {
                enemiesKilledRecently += gameHistory[i].enemiesKilledThisTurn || 0;
            }
            if (enemiesKilledRecently >= MASSACRE_COUNT && !eventFlags.massacre) {
                const isMajor = enemiesKilledRecently >= MASSACRE_COUNT * 3; // Much stricter - only mega massacres
                const logMessage = `${player.name} has achieved a MASSACRE, eliminating ${enemiesKilledRecently} enemies in rapid succession!`;
                addEventMessage("Massacre", isMajor, logMessage);
                eventFlags.massacre = true;
            } else if (enemiesKilledRecently < MASSACRE_COUNT) {
                eventFlags.massacre = false;
            }

            // Berserker Mode
            let recentDamage = 0;
            for (let i = Math.max(0, gameHistory.length - BERSERKER_TURNS); i < gameHistory.length; i++) {
                recentDamage += gameHistory[i].damageDealtThisTurn || 0;
            }
            if (recentDamage >= BERSERKER_DAMAGE_THRESHOLD && !eventFlags.berserkerMode) {
                const isMajor = recentDamage >= BERSERKER_DAMAGE_THRESHOLD * 3; // Much stricter - only extreme berserker
                const logMessage = `${player.name} enters BERSERKER MODE, dealing ${recentDamage} damage in ${BERSERKER_TURNS} turns!`;
                addEventMessage("Berserker Mode", isMajor, logMessage);
                eventFlags.berserkerMode = true;
            } else if (recentDamage < BERSERKER_DAMAGE_THRESHOLD) {
                eventFlags.berserkerMode = false;
            }

            // Glass Cannon
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.3 && 
                damageDealtThisTurn >= player.health * GLASS_CANNON_DAMAGE_RATIO && 
                !eventFlags.glassCannon) {
                const isMajor = damageDealtThisTurn >= player.health * GLASS_CANNON_DAMAGE_RATIO * 4; // Much stricter - only extreme glass cannon
                const logMessage = `${player.name} demonstrates GLASS CANNON tactics, dealing ${damageDealtThisTurn} damage while having only ${player.health} health!`;
                addEventMessage("Glass Cannon", isMajor, logMessage);
                eventFlags.glassCannon = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * 0.3 || damageDealtThisTurn < player.health * GLASS_CANNON_DAMAGE_RATIO) {
                eventFlags.glassCannon = false;
            }

            // Headhunter
            const highValueEnemiesKilled = killedEnemiesThisTurn.filter(name => {
                const enemy = gameHistory.length > 1 ? 
                    gameHistory[gameHistory.length - 2].enemiesPositions.find(e => e.name === name) : null;
                return enemy && enemy.health >= HEADHUNTER_HIGH_VALUE_ENEMY;
            });
            if (highValueEnemiesKilled.length > 0 && !eventFlags.headhunter) {
                const isMajor = highValueEnemiesKilled.length >= 3; // Only 3+ high-value kills in one turn
                const targets = highValueEnemiesKilled.join(', ');
                const logMessage = `${player.name} is a HEADHUNTER, taking down high-value targets: ${targets}`;
                addEventMessage("Headhunter", isMajor, logMessage);
                eventFlags.headhunter = true;
            } else if (highValueEnemiesKilled.length === 0) {
                eventFlags.headhunter = false;
            }

            // === COMBAT EVENTS - DEFENSIVE ===

            // Last Stand
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * LAST_STAND_HEALTH_RATIO && 
                enemies.length >= 2 && damageDealtThisTurn > 0 && !eventFlags.lastStand) {
                const isMajor = enemies.length >= 6; // Only against overwhelming odds
                const logMessage = `${player.name} makes a LAST STAND with ${player.health} health against ${enemies.length} enemies!`;
                addEventMessage("Last Stand", isMajor, logMessage);
                eventFlags.lastStand = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * LAST_STAND_HEALTH_RATIO) {
                eventFlags.lastStand = false;
            }

            // Narrow Escape
            if (previousTurn && previousTurn.playerHealth <= PLAYER_VISUAL_HEALTH_THRESHOLD * NARROW_ESCAPE_HEALTH_RATIO && 
                player.health > previousTurn.playerHealth && !eventFlags.narrowEscape) {
                const isMajor = previousTurn.playerHealth <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.03;
                const logMessage = `${player.name} had a NARROW ESCAPE, surviving with only ${previousTurn.playerHealth} health!`;
                addEventMessage("Narrow Escape", isMajor, logMessage);
                eventFlags.narrowEscape = true;
            } else if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * NARROW_ESCAPE_HEALTH_RATIO) {
                eventFlags.narrowEscape = false;
            }

            // Damage Sponge
            let recentDamageAbsorbed = 0;
            for (let i = Math.max(0, gameHistory.length - 5); i < gameHistory.length; i++) {
                recentDamageAbsorbed += gameHistory[i].hitsTakenThisTurn || 0;
            }
            if (recentDamageAbsorbed >= DAMAGE_SPONGE_THRESHOLD && player.health > 0 && !eventFlags.damageSponge) {
                const isMajor = recentDamageAbsorbed >= DAMAGE_SPONGE_THRESHOLD * 1.5;
                const logMessage = `${player.name} is a DAMAGE SPONGE, absorbing ${recentDamageAbsorbed} damage while staying alive!`;
                addEventMessage("Damage Sponge", isMajor, logMessage);
                eventFlags.damageSponge = true;
            } else if (recentDamageAbsorbed < DAMAGE_SPONGE_THRESHOLD) {
                eventFlags.damageSponge = false;
            }

            // Iron Will
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * IRON_WILL_LOW_HEALTH_COMBAT && 
                combatOccurredThisTurn && !playerTookDamageInCombatThisTurn && !eventFlags.ironWill) {
                const isMajor = player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.1;
                const logMessage = `${player.name} shows IRON WILL, fighting at ${player.health} health without taking damage!`;
                addEventMessage("Iron Will", isMajor, logMessage);
                eventFlags.ironWill = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * IRON_WILL_LOW_HEALTH_COMBAT || playerTookDamageInCombatThisTurn) {
                eventFlags.ironWill = false;
            }

            // === TACTICAL EVENTS ===

            // Tactical Advance
            if (previousTurn && enemies.length > 0) {
                const closestEnemyBefore = getClosestEntity(previousTurn.enemiesPositions, {x: previousTurn.playerX, y: previousTurn.playerY});
                const closestEnemyNow = getClosestEntity(enemies, player);
                if (closestEnemyBefore && closestEnemyNow) {
                    const distBefore = getDistance({x: previousTurn.playerX, y: previousTurn.playerY}, closestEnemyBefore);
                    const distNow = getDistance(player, closestEnemyNow);
                    if (distBefore - distNow >= TACTICAL_ADVANCE_DISTANCE && damageDealtThisTurn > 0 && !eventFlags.tacticalAdvance) {
                        const isMajor = distBefore - distNow >= TACTICAL_ADVANCE_DISTANCE * 1.5;
                        const logMessage = `${player.name} executes TACTICAL ADVANCE, closing ${distBefore - distNow} tiles and dealing ${damageDealtThisTurn} damage!`;
                        addEventMessage("Tactical Advance", isMajor, logMessage);
                        eventFlags.tacticalAdvance = true;
                    } else if (distBefore - distNow < TACTICAL_ADVANCE_DISTANCE) {
                        eventFlags.tacticalAdvance = false;
                    }
                }
            }

            // Guerrilla Warfare
            let hitAndRunCount = 0;
            for (let i = Math.max(0, gameHistory.length - GUERRILLA_HIT_AND_RUN); i < gameHistory.length; i++) {
                if (gameHistory[i].damageDealtThisTurn > 0 && gameHistory[i].hitsTakenThisTurn === 0) {
                    hitAndRunCount++;
                }
            }
            if (hitAndRunCount >= GUERRILLA_HIT_AND_RUN && !eventFlags.guerrillaWarfare) {
                const isMajor = hitAndRunCount >= GUERRILLA_HIT_AND_RUN + 2;
                const logMessage = `${player.name} employs GUERRILLA WARFARE, ${hitAndRunCount} consecutive hit-and-run attacks!`;
                addEventMessage("Guerrilla Warfare", isMajor, logMessage);
                eventFlags.guerrillaWarfare = true;
            } else if (hitAndRunCount < GUERRILLA_HIT_AND_RUN) {
                eventFlags.guerrillaWarfare = false;
            }

            // === RESOURCE MANAGEMENT ===

            // Greedy Collector
            const totalPickupsAvailable = staticDamageNumbers.filter(s => !s.isPlayerRemains).length;
            const pickupEfficiency = totalPickupsAvailable > 0 ? 
                (totalPickupValueCollectedThisTurn / totalPickupsAvailable) : 0;
            if (pickupEfficiency >= GREEDY_COLLECTOR_RATIO && totalPickupValueCollectedThisTurn > 0 && !eventFlags.greedyCollector) {
                const isMajor = pickupEfficiency >= 1.0;
                const logMessage = `${player.name} is a GREEDY COLLECTOR, gathering ${totalPickupValueCollectedThisTurn} resources with ${Math.round(pickupEfficiency * 100)}% efficiency!`;
                addEventMessage("Greedy Collector", isMajor, logMessage);
                eventFlags.greedyCollector = true;
            } else if (pickupEfficiency < GREEDY_COLLECTOR_RATIO) {
                eventFlags.greedyCollector = false;
            }

            // Resource Hoarder
            let totalResourcesHoarded = 0;
            for (let i = Math.max(0, gameHistory.length - 10); i < gameHistory.length; i++) {
                totalResourcesHoarded += gameHistory[i].totalPickupValueCollectedThisTurn || 0;
            }
            if (totalResourcesHoarded >= RESOURCE_HOARDER_COUNT && !eventFlags.resourceHoarder) {
                const isMajor = totalResourcesHoarded >= RESOURCE_HOARDER_COUNT * 2;
                const logMessage = `${player.name} is a RESOURCE HOARDER, collecting ${totalResourcesHoarded} total resources recently!`;
                addEventMessage("Resource Hoarder", isMajor, logMessage);
                eventFlags.resourceHoarder = true;
            } else if (totalResourcesHoarded < RESOURCE_HOARDER_COUNT) {
                eventFlags.resourceHoarder = false;
            }

            // === EXPLORATION EVENTS ===

            // Speed Runner
            const levelCompletionRatio = enemies.length === 0 ? 1.0 : (currentTurn.enemiesCount === 0 ? 1.0 : 0);
            if (levelCompletionRatio >= SPEED_RUNNER_PERCENTAGE && stepsTaken <= SPEEDSTER_TURN_LIMIT && !eventFlags.speedRunner) {
                const isMajor = stepsTaken <= SPEEDSTER_TURN_LIMIT * 0.7;
                const logMessage = `${player.name} is a SPEED RUNNER, completing level in ${stepsTaken} turns!`;
                addEventMessage("Speed Runner", isMajor, logMessage);
                eventFlags.speedRunner = true;
            }

            // Cartographer
            const mapCoverage = countVisitedTiles() / (dynamicMapWidth * dynamicMapHeight);
            if (mapCoverage >= CARTOGRAPHER_MAP_COVERAGE && !eventFlags.cartographer) {
                const isMajor = mapCoverage >= 0.98;
                const logMessage = `${player.name} is a CARTOGRAPHER, mapping ${Math.round(mapCoverage * 100)}% of the area!`;
                addEventMessage("Cartographer", isMajor, logMessage);
                eventFlags.cartographer = true;
            } else if (mapCoverage < CARTOGRAPHER_MAP_COVERAGE) {
                eventFlags.cartographer = false;
            }

            // === HEALTH & RECOVERY ===

            // Regeneration
            if (previousTurn && player.health - previousTurn.playerHealth >= REGENERATION_HEALTH_GAIN && !eventFlags.regeneration) {
                const isMajor = player.health - previousTurn.playerHealth >= REGENERATION_HEALTH_GAIN * 1.5;
                const healthGained = player.health - previousTurn.playerHealth;
                const logMessage = `${player.name} shows REGENERATION, gaining ${healthGained} health in one turn!`;
                addEventMessage("Regeneration", isMajor, logMessage);
                eventFlags.regeneration = true;
            } else if (!previousTurn || player.health - previousTurn.playerHealth < REGENERATION_HEALTH_GAIN) {
                eventFlags.regeneration = false;
            }

            // Vitality
            if (player.health >= PLAYER_VISUAL_HEALTH_THRESHOLD * VITALITY_HIGH_HEALTH_COMBAT && 
                combatOccurredThisTurn && damageDealtThisTurn > 0 && !eventFlags.vitality) {
                const isMajor = player.health >= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.9;
                const logMessage = `${player.name} demonstrates VITALITY, fighting at ${player.health} health and dealing ${damageDealtThisTurn} damage!`;
                addEventMessage("Vitality", isMajor, logMessage);
                eventFlags.vitality = true;
            } else if (player.health < PLAYER_VISUAL_HEALTH_THRESHOLD * VITALITY_HIGH_HEALTH_COMBAT || !combatOccurredThisTurn) {
                eventFlags.vitality = false;
            }

            // === PSYCHOLOGICAL EVENTS ===

            // Confidence
            const currentFlow = currentTurn.playerFlow;
            if (currentFlow >= CONFIDENCE_HIGH_FLOW && player.health >= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.6 && !eventFlags.confidence) {
                const isMajor = currentFlow >= CONFIDENCE_HIGH_FLOW * 1.5;
                const logMessage = `${player.name} radiates CONFIDENCE with ${currentFlow.toFixed(2)} flow and ${player.health} health!`;
                addEventMessage("Confidence", isMajor, logMessage);
                eventFlags.confidence = true;
            } else if (currentFlow < CONFIDENCE_HIGH_FLOW || player.health < PLAYER_VISUAL_HEALTH_THRESHOLD * 0.6) {
                eventFlags.confidence = false;
            }

            // Desperation
            if (player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * DESPERATION_LOW_HEALTH && 
                enemies.length >= 2 && !eventFlags.desperation) {
                const isMajor = player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.05;
                const logMessage = `${player.name} fights with DESPERATION, ${player.health} health against ${enemies.length} enemies!`;
                addEventMessage("Desperation", isMajor, logMessage);
                eventFlags.desperation = true;
            } else if (player.health > PLAYER_VISUAL_HEALTH_THRESHOLD * DESPERATION_LOW_HEALTH || enemies.length < 2) {
                eventFlags.desperation = false;
            }

            // === ACHIEVEMENT EVENTS ===

            // First Blood (only triggers on level 1)
            if (currentLevel === FIRST_BLOOD_LEVEL && enemiesKilledThisTurn > 0 && !eventFlags.firstBlood) {
                const isMajor = false;
                const logMessage = `${player.name} draws FIRST BLOOD in the division!`;
                addEventMessage("First Blood", isMajor, logMessage);
                eventFlags.firstBlood = true;
            }

            // Perfectionist
            if (enemies.length === 0 && hitsTaken === 0 && stepsTaken > 5 && !eventFlags.perfectionist) {
                const isMajor = false; // Too common and redundant with Flawless Victory
                const logMessage = `${player.name} achieves PERFECTIONIST status, completing level without taking damage!`;
                addEventMessage("Perfectionist", isMajor, logMessage);
                eventFlags.perfectionist = true;
            }

            // === LEGACY EVENTS (Updated) ===
            
            // Player Surrounded
            let adjacentEnemiesCount = 0;
            let adjacentEnemies = [];
            const eightDirections = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dx, dy] of eightDirections) {
                const checkX = player.x + dx;
                const checkY = player.y + dy;
                const adjacentEnemy = enemies.find(e => e.x === checkX && e.y === checkY);
                if (adjacentEnemy) {
                    adjacentEnemiesCount++;
                    adjacentEnemies.push(adjacentEnemy);
                }
            }
            if (adjacentEnemiesCount >= SURROUNDED_THRESHOLD && !eventFlags.playerSurrounded) {
                const isMajor = adjacentEnemiesCount >= SURROUNDED_MAJOR_THRESHOLD;
                const enemyNames = adjacentEnemies.map(e => e.name).join(', ');
                const logMessage = `${player.name} is SURROUNDED by ${enemyNames} (${adjacentEnemiesCount} enemies)`;
                addEventMessage("Player Surrounded", isMajor, logMessage);
                eventFlags.playerSurrounded = true;
            } else if (adjacentEnemiesCount < SURROUNDED_THRESHOLD) {
                eventFlags.playerSurrounded = false;
            }

            // Near-Death Recovery
            const wasLowHealthThreshold = PLAYER_VISUAL_HEALTH_THRESHOLD * NEAR_DEATH_HEALTH_RATIO;
            const recoveryThreshold = PLAYER_VISUAL_HEALTH_THRESHOLD * RECOVERY_HEALTH_GAIN_RATIO;

            if (player.health <= wasLowHealthThreshold && !player.wasLowHealth) {
                player.wasLowHealth = true;
                player.lowestHealthReached = player.health;
            } else if (player.wasLowHealth && player.health >= player.lowestHealthReached + recoveryThreshold) {
                if (!eventFlags.nearDeathRecovery) {
                    const isMajor = player.lowestHealthReached <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.1;
                    const logMessage = `${player.name} makes NEAR-DEATH RECOVERY from ${player.lowestHealthReached} to ${player.health} health!`;
                    addEventMessage("Near-Death Recovery", isMajor, logMessage);
                    eventFlags.nearDeathRecovery = true;
                }
                player.wasLowHealth = false;
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
            } else if (player.health > wasLowHealthThreshold && player.wasLowHealth && player.health < player.lowestHealthReached + recoveryThreshold) {
                player.wasLowHealth = false;
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
                eventFlags.nearDeathRecovery = false;
            } else if (player.health > wasLowHealthThreshold && !player.wasLowHealth) {
                eventFlags.nearDeathRecovery = false;
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
            }

            // Killing Spree (Updated)
            if (enemiesKilledRecently >= KILLING_SPREE_COUNT && !eventFlags.killingSpree) {
                const isMajor = enemiesKilledRecently >= KILLING_SPREE_MAJOR_COUNT;
                let recentKilledEnemies = [];
                for (let i = Math.max(0, gameHistory.length - KILLING_SPREE_COUNT); i < gameHistory.length; i++) {
                    if (gameHistory[i].killedEnemyNames) {
                        recentKilledEnemies = recentKilledEnemies.concat(gameHistory[i].killedEnemyNames);
                    }
                }
                const killedNames = recentKilledEnemies.length > 0 ? recentKilledEnemies.join(', ') : 'multiple enemies';
                const logMessage = `${player.name} goes on KILLING SPREE, eliminating ${enemiesKilledRecently} enemies: ${killedNames}`;
                addEventMessage("Killing Spree", isMajor, logMessage);
                eventFlags.killingSpree = true;
            } else if (enemiesKilledRecently < KILLING_SPREE_COUNT) {
                eventFlags.killingSpree = false;
            }

            // Other legacy events with similar updates...
            // (Continuing with existing logic but enhanced logging)

            // NEW: 13. "Perfect Dodge"
            // Only check if combat occurred this turn and player took no damage from combat
            if (combatOccurredThisTurn && !playerTookDamageInCombatThisTurn && !eventFlags.perfectDodge) {
                addEventMessage("Perfect Dodge!");
                eventFlags.perfectDodge = true;
            } else if (!combatOccurredThisTurn || playerTookDamageInCombatThisTurn) {
                eventFlags.perfectDodge = false;
            }

            // NEW: 14. "Flawless Victory" (for a level)
            // This needs to be checked when advancing to the next level, not every turn.
            // We'll add a check in `nextLevel()` or `initGame()` when `resetGameStats` is false.
        }

        /**
         * Advances the player to the next level.
         */
        function nextLevel() {
            console.log("DEBUG: nextLevel() called - Player health before level transition:", player.health);
            // Check for "Flawless Victory" before resetting stats for the new level
            const previousLevelState = gameHistory.find(state => state.currentLevel === currentLevel); // Find state from the start of this level
            let totalDamageTakenThisLevel = 0;
            if (previousLevelState) {
                totalDamageTakenThisLevel = hitsTaken - previousLevelState.hitsTaken;
            }
            if (totalDamageTakenThisLevel === 0 && !eventFlags.flawlessVictory) {
                const isMajor = true;
                const logMessage = `${player.name} achieved FLAWLESS VICTORY on Level ${currentLevel} - no damage taken!`;
                addEventMessage("Flawless Victory!", isMajor, logMessage);
                eventFlags.flawlessVictory = true;
            } else {
                eventFlags.flawlessVictory = false;
            }

            // --- Begin new scoring breakdown logic ---
            // Calculate per-level score breakdown before resetting for next level
            let baseDamage = typeof levelStartDamage === 'number' ? (totalDamageDealt - levelStartDamage) : totalDamageDealt;
            let speedBonus = 0;
            let fullClearBonus = 0;
            let enemyPenalty = 0;
            let levelSteps = stepsTaken;
            let levelHitsTaken = hitsTaken;

            // Speed bonus: reward for finishing quickly (level number minus steps taken)
            if (stepsTaken > 0 && enemies.length === 0) {
                speedBonus = Math.max(0, currentLevel - stepsTaken);
            }

            // Full clear bonus: all enemies defeated
            if (enemies.length === 0) {
                fullClearBonus = currentLevel;
            }

            // Enemy penalty: sum of remaining enemies' health (point value)
            if (enemies.length > 0) {
                enemyPenalty = enemies.reduce((sum, e) => sum + (e.health || 0), 0);
            }


            // Save breakdown for UI and update level score history
            lastLevelScoreBreakdown = {
                level: currentLevel,
                baseDamage,
                speedBonus,
                fullClearBonus,
                enemyPenalty,
                levelSteps,
                levelHitsTaken
            };


            // Format breakdown string to show literal calculation
            let formulaParts = [`Dmg:${baseDamage}`];
            if (speedBonus) formulaParts.push(`Spd:${speedBonus}`);
            if (fullClearBonus) formulaParts.push(`Clr:${fullClearBonus}`);
            if (enemyPenalty) formulaParts.push(`Pen:${enemyPenalty}`);
            let formula = formulaParts.join(' + ');
            if (enemyPenalty) formula = formula.replace(`Pen:${enemyPenalty}`, `- Pen:${enemyPenalty}`);
            // Only declare levelScore once
            let levelScore = baseDamage + speedBonus + fullClearBonus - enemyPenalty;
            let breakdownText = `L${currentLevel}:  ${formula} = ${levelScore}`;

            // Maintain a global array for level score history
            if (!window.levelScoreHistory) window.levelScoreHistory = [];
            window.levelScoreHistory.push(breakdownText);
            // Limit to last 8 levels for display
            if (window.levelScoreHistory.length > 8) window.levelScoreHistory.shift();

            // Apply score changes
            totalScore += levelScore;

            // --- End new scoring breakdown logic ---

            // Preserve auto mode across level transitions
            const previousAutoMode = autoMode;

            // Check for world progression (need points = level * 10)
            const currentScore = stepsTaken > 0 ? Math.floor(totalDamageDealt * (totalDamageDealt / stepsTaken)) : 0;
            const pointsNeededForNextWorld = (currentLevel + 1) * 10;

            // Check if we should advance to next world
            if (currentScore >= pointsNeededForNextWorld && WORLDS[currentWorld + 1] && !unlockedWorlds.includes(currentWorld + 1)) {
                currentWorld = currentWorld + 1;
                unlockedWorlds.push(currentWorld);
                console.log(`Advanced to World ${currentWorld}: ${getCurrentWorld().name}!`);
                addKillMessage(`🌍 ENTERED ${getCurrentWorld().name.toUpperCase()}! 🌍`);
            }

            currentLevel = currentLevel + 1; // Explicit assignment
            initGame(false); // No overlay when progressing levels

            // Restart auto mode if it was active
            if (previousAutoMode) {
                autoMode = previousAutoMode;
                startAutomatedMovement();
            }
        }

        /**
         * Stops all automated movement (P, E modes, or Tab-based full auto-move).
         */
        function stopAutomatedMovement() {
            if (autoMoveTimeoutId) {
                clearTimeout(autoMoveTimeoutId);
                autoMoveTimeoutId = null;
            }
            autoMode = null;
            autoMovePath = [];
            currentPathIndex = 0;
        }

        /**
         * Finds the closest entity from a list to the player, optionally within a radius.
         * @param {object[]} entities - The list of entities ({x, y}).
         * @param {object} playerPos - The player's current position {x, y}.
         * @param {number} radius - Optional maximum distance to consider. Defaults to Infinity.
         * @returns {object|null} The closest entity, or null if none found within radius.
         */
        function getClosestEntity(entities, playerPos, radius = Infinity) {
            let closest = null;
            let minDist = Infinity;
            entities.forEach(entity => {
                if (entity && typeof entity.x === 'number' && typeof entity.y === 'number') {
                    const dist = getDistance(playerPos, entity);
                    if (dist <= radius && dist < minDist) {
                        minDist = dist;
                        closest = entity;
                    }
                }
            });
            return closest;
        }

        /**
         * Starts the appropriate automated movement mode (P or E).
         * This function determines the target based on the active autoMode and initiates the pathfinding.
         */
        function startAutomatedMovement() {
            if (gameOver) {
                stopAutomatedMovement();
                return;
            }
            if (autoMode === null) return;

            // Set speed for H mode
            AUTO_MOVE_SPEED = DEFAULT_AUTO_MOVE_SPEED;

            if (autoMoveTimeoutId) {
                clearTimeout(autoMoveTimeoutId);
                autoMoveTimeoutId = null;
            }

            autoMovePath = [];
            currentPathIndex = 0;

            let targetDestination = null;
            let pathFunction = findPathBasic;
            let pathPenaltyEntities = [];

            const allEnemies = enemies;
            const allPickups = staticDamageNumbers.filter(s => !s.isPlayerRemains); // Only actual pickups, not player remains

            if (autoMode === 'highScore') {
                // Enhanced HIGH_SCORE mode: maximize score while minimizing risk
                const isPlayerLowHealth = player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * HIGH_SCORE_LOW_HEALTH_THRESHOLD_RATIO;
                const isPlayerVeryLowHealth = player.health <= PLAYER_VISUAL_HEALTH_THRESHOLD * 0.15; // Critical health
                const allEnemiesPresent = enemies.length > 0;
                
                const weakEnemies = allEnemies.filter(e => e.health <= player.health * HIGH_SCORE_WEAK_ENEMY_THRESHOLD_RATIO);
                const moderateEnemies = allEnemies.filter(e => e.health > player.health * HIGH_SCORE_WEAK_ENEMY_THRESHOLD_RATIO && e.health <= player.health * 1.5);
                const strongEnemies = allEnemies.filter(e => e.health > player.health * 1.5);
                
                const closestPickup = getClosestEntity(allPickups, player);
                const closestWeakEnemy = getClosestEntity(weakEnemies, player);
                const closestModerateEnemy = getClosestEntity(moderateEnemies, player);
                const closestStrongEnemy = getClosestEntity(strongEnemies, player);

                // Priority logic for high score optimization
                if (isPlayerVeryLowHealth && closestPickup) {
                    // Critical health - prioritize healing above all else
                    targetDestination = closestPickup;
                    pathPenaltyEntities = allEnemies; // Avoid all enemies
                } else if (isPlayerLowHealth && closestPickup && (!closestWeakEnemy || getDistance(player, closestPickup) < getDistance(player, closestWeakEnemy) * 0.7)) {
                    // Low health but not critical - prefer nearby pickups over distant weak enemies
                    targetDestination = closestPickup;
                    pathPenaltyEntities = [...moderateEnemies, ...strongEnemies]; // Avoid stronger enemies
                } else if (closestWeakEnemy && (!isPlayerLowHealth || getDistance(player, closestWeakEnemy) <= 3)) {
                    // Target weak enemies for easy score, unless low health and enemy is far
                    targetDestination = closestWeakEnemy;
                    pathPenaltyEntities = [...moderateEnemies, ...strongEnemies]; // Avoid stronger enemies
                } else if (closestPickup && closestModerateEnemy && getDistance(player, closestPickup) < getDistance(player, closestModerateEnemy) * 0.5) {
                    // Prefer very close pickups over moderate enemies
                    targetDestination = closestPickup;
                    pathPenaltyEntities = [...moderateEnemies, ...strongEnemies];
                } else if (closestModerateEnemy && !isPlayerLowHealth) {
                    // Fight moderate enemies when healthy
                    targetDestination = closestModerateEnemy;
                    pathPenaltyEntities = strongEnemies; // Avoid only strong enemies
                } else if (closestPickup) {
                    // Default to pickups when no good enemy targets
                    targetDestination = closestPickup;
                    pathPenaltyEntities = allEnemies;
                } else if (!isPlayerLowHealth && closestStrongEnemy && strongEnemies.length === 1) {
                    // Fight single strong enemy if healthy and no other options
                    targetDestination = closestStrongEnemy;
                    pathPenaltyEntities = [];
                } else {
                    // No good options remaining, head to stairs
                    targetDestination = stairs;
                    pathPenaltyEntities = allEnemies;
                }
                pathFunction = findPathWithProximityPenalty;
            }

            if (targetDestination) {
                // For auto-movement, entities should avoid certain obstacles.
                // If the target is stairs, stairs should NOT be an obstacle.
                const entitiesToAvoidForAutoMove = [...pathPenaltyEntities];
                if (targetDestination !== stairs && stairs) { // Only add stairs to avoid if stairs are NOT the target
                    entitiesToAvoidForAutoMove.push(stairs);
                }
                const path = pathFunction(player.x, player.y, targetDestination.x, targetDestination.y, gameMap, dynamicMapWidth, dynamicMapHeight, entitiesToAvoidForAutoMove);
                if (path && path.length > 1) {
                    autoMovePath = path;
                    executeAutoMoveStep();
                } else {
                    console.warn(`No clear path found to target (${targetDestination.x}, ${targetDestination.y}). Stopping auto-movement.`);
                    stopAutomatedMovement();
                }
            } else {
                console.warn("No target destination for auto-movement. Stopping auto-movement.");
                stopAutomatedMovement();
            }
        }

        /**
         * Executes one step of the automated movement path for P/E modes.
         * This function is called recursively by setTimeout.
         */
        function executeAutoMoveStep() {
            if (gameOver || autoMode === null) {
                stopAutomatedMovement();
                return;
            }

            if (!autoMovePath || autoMovePath.length === 0 || currentPathIndex >= autoMovePath.length) {
                // If path is exhausted or invalid, try to find a new path (e.g., if new enemies spawned)
                autoMoveTimeoutId = setTimeout(startAutomatedMovement, AUTO_MOVE_SPEED);
                return;
            }

            const nextPos = autoMovePath[currentPathIndex];
            const dx = nextPos.x - player.x;
            const dy = nextPos.y - player.y;

            const combatOccurred = movePlayer(dx, dy);

            if (gameOver) {
                stopAutomatedMovement();
                return;
            }

            const delay = combatOccurred ? COMBAT_MOVE_DELAY : AUTO_MOVE_SPEED;

            // Check if we need to recalculate path
            let shouldRecalculate = false;
            
            if (player.x !== nextPos.x || player.y !== nextPos.y || combatOccurred) {
                shouldRecalculate = true;
            }

            if (shouldRecalculate) {
                autoMoveTimeoutId = setTimeout(startAutomatedMovement, delay);
                return;
            }

            currentPathIndex = currentPathIndex + 1; // Explicit assignment
            autoMoveTimeoutId = setTimeout(executeAutoMoveStep, delay);
        }

        /**
         * Handles keyboard input for player movement.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyDown(event) {
            // If the game start overlay is active, any key press will dismiss it
            if (gameStartedOverlayActive) {
                gameStartedOverlayActive = false;
                event.preventDefault();
                return;
            }

            // Only process game input if the game is running
            if (!isGameRunning) {
                return;
            }

            // Always handle space bar for teleport
            if (event.key === ' ') {
                event.preventDefault();
                if (!gameOver) {
                    emergencyTeleport();
                }
                return;
            }

            // Stop auto mode on any key press except H
            if (autoMode !== null && event.key !== 'h' && event.key !== 'H') {
                stopAutomatedMovement();
            }

            if (event.key === 'h' || event.key === 'H') {
                event.preventDefault();
                if (autoMode === 'highScore') {
                    stopAutomatedMovement();
                } else {
                    stopAutomatedMovement();
                    autoMode = 'highScore';
                    startAutomatedMovement();
                }
                return;
            }

            // World switching controls (1-9 keys)
            if (['1','2','3','4','5','6','7','8','9'].includes(event.key)) {
                event.preventDefault();
                const worldNumber = parseInt(event.key);
                if (WORLDS[worldNumber] && worldNumber !== currentWorld) {
                    currentWorld = worldNumber;
                    unlockedWorlds = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                    setupWorldColors();
                    initGame(true, false);
                    console.log(`Switched to world ${worldNumber}: ${WORLDS[worldNumber].name}`);
                }
                return;
            }

            if (gameOver) {
                event.preventDefault();
                return;
            }

            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    movePlayer(1, 0);
                    break;
            }
        }

        // Controller/Gamepad Support Variables
        let gamepadIndex = -1;
        let lastGamepadState = {
            buttons: [],
            axes: []
        };
        const GAMEPAD_DEADZONE = 0.3;
        const GAMEPAD_POLL_INTERVAL = 16; // ~60fps polling

        /**
         * Detects connected gamepads and sets up gamepad support
         */
        function detectGamepad() {
            const gamepads = navigator.getGamepads();
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i]) {
                    gamepadIndex = i;
                    console.log(`Gamepad connected: ${gamepads[i].id}`);
                    break;
                }
            }
        }

        /**
         * Handles gamepad input polling
         */
        function handleGamepadInput() {
            if (gamepadIndex === -1) return;

            const gamepad = navigator.getGamepads()[gamepadIndex];
            if (!gamepad) {
                gamepadIndex = -1;
                return;
            }

            // Handle D-pad and analog stick movement
            let dx = 0;
            let dy = 0;

            // D-pad (buttons 12, 13, 14, 15 are standard D-pad)
            if (gamepad.buttons[12] && gamepad.buttons[12].pressed) dy = -1; // Up
            if (gamepad.buttons[13] && gamepad.buttons[13].pressed) dy = 1;  // Down
            if (gamepad.buttons[14] && gamepad.buttons[14].pressed) dx = -1; // Left
            if (gamepad.buttons[15] && gamepad.buttons[15].pressed) dx = 1;  // Right

            // Left analog stick (axes 0 and 1)
            if (Math.abs(gamepad.axes[0]) > GAMEPAD_DEADZONE) {
                if (gamepad.axes[0] > GAMEPAD_DEADZONE) dx = 1;
                else if (gamepad.axes[0] < -GAMEPAD_DEADZONE) dx = -1;
            }
            if (Math.abs(gamepad.axes[1]) > GAMEPAD_DEADZONE) {
                if (gamepad.axes[1] > GAMEPAD_DEADZONE) dy = 1;
                else if (gamepad.axes[1] < -GAMEPAD_DEADZONE) dy = -1;
            }

            // Only move if there's input and it's different from last frame
            if ((dx !== 0 || dy !== 0) && !gameOver) {
                const currentInput = `${dx},${dy}`;
                const lastInput = `${lastGamepadState.dx || 0},${lastGamepadState.dy || 0}`;
                
                // Only process movement if it's a new input or enough time has passed
                if (currentInput !== lastInput || !lastGamepadState.lastMoveTime || 
                    performance.now() - lastGamepadState.lastMoveTime > 150) {
                    movePlayer(dx, dy);
                    lastGamepadState.lastMoveTime = performance.now();
                }
                lastGamepadState.dx = dx;
                lastGamepadState.dy = dy;
            } else {
                lastGamepadState.dx = 0;
                lastGamepadState.dy = 0;
            }

            // Handle automation mode buttons
            // (Gamepad automation controls removed)

            // Start button (button 9) - Restart game when game over
            if (gameOver && gamepad.buttons[9] && gamepad.buttons[9].pressed && !lastGamepadState.buttons[9]) {
                // Trigger restart animation and game restart
                const restartText = "PRESS R TO RESTART";
                const baseFontSize = Math.floor(dynamicTileSize * 0.8);
                ctx.font = `${baseFontSize}px VT323`;
                const textMetrics = ctx.measureText(restartText);
                const textWidth = textMetrics.width;

                const textX = gameCanvas.width / 2;
                const textY = gameCanvas.height / 2 + dynamicTileSize * 1.5;

                // Generate particles for each character
                restartTextParticles = [];
                let currentTextX = textX - textWidth / 2;
                const charSpacing = textWidth / restartText.length;

                for (let i = 0; i < restartText.length; i++) {
                    const char = restartText[i];
                    const charX = currentTextX + charSpacing * i + charSpacing / 2;
                    const charY = textY;

                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 0.5 + 0.2) * (dynamicTileSize / 20);
                    const dirX = Math.cos(angle);
                    const dirY = Math.sin(angle);
                    const fadeFactor = Math.random() * 0.7 + 0.3;

                    restartTextParticles.push({
                        char: char,
                        startX: charX,
                        startY: charY,
                        dirX: dirX,
                        dirY: dirY,
                        initialSpeed: speed,
                        fontSize: baseFontSize,
                        color: '#FFD700',
                        startTime: performance.now(),
                        duration: RESTART_TEXT_EXPLOSION_DURATION,
                        fadeFactor: fadeFactor
                    });
                }

                restartTextAnimationActive = true;
                restartTextAnimationStartTime = performance.now();
                restartGame();
            }

            // Any face button - Dismiss game start overlay
            if (gameStartedOverlayActive && 
                ((gamepad.buttons[0] && gamepad.buttons[0].pressed) ||
                 (gamepad.buttons[1] && gamepad.buttons[1].pressed) ||
                 (gamepad.buttons[2] && gamepad.buttons[2].pressed) ||
                 (gamepad.buttons[3] && gamepad.buttons[3].pressed))) {
                gameStartedOverlayActive = false;
            }

            // Store button states for next frame
            lastGamepadState.buttons = gamepad.buttons.map(button => button.pressed);
        }

        /**
         * Starts gamepad polling
         */
        function startGamepadPolling() {
            setInterval(() => {
                if (gamepadIndex === -1) {
                    detectGamepad();
                } else {
                    handleGamepadInput();
                }
            }, GAMEPAD_POLL_INTERVAL);
        }

        // Gamepad connection event listeners
        window.addEventListener('gamepadconnected', (e) => {
            console.log(`Gamepad connected: ${e.gamepad.id}`);
            gamepadIndex = e.gamepad.index;
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log(`Gamepad disconnected: ${e.gamepad.id}`);
            if (e.gamepad.index === gamepadIndex) {
                gamepadIndex = -1;
            }
        });

        /**
         * The main animation loop.
         * @param {DOMHighResTimeStamp} currentTime - The current time provided by requestAnimationFrame.
         */
        function animate(currentTime) {
            try {
                animationFrameId = requestAnimationFrame(animate);
                drawGame();
            }
            catch (error) {
                console.error("Error in animation loop:", error);
                stopAnimationLoop(); // Stop the loop to prevent further errors
                handleGameOver(); // Attempt to gracefully end the game
            }
        }

        /**
         * Starts the animation loop.
         */
        function startAnimationLoop() {
            console.log('Starting animation loop...');
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(animate);
            console.log('Animation loop started with ID:', animationFrameId);
        }

        /**
         * Stops the animation loop.
         */
        function stopAnimationLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        /**
         * Calculates the current score.
         */
        function calculateScore() {
            let score = 0;
            if (stepsTaken > 0) {
                const averageDamagePerTurn = totalDamageDealt / stepsTaken;
                score = Math.floor(totalDamageDealt * averageDamagePerTurn);
            }
            return score;
        }

        /**
         * Loads high scores from local storage. (Function kept for potential future use, not currently displayed)
         */
        function loadHighScores() {
            const storedScores = localStorage.getItem(HIGH_SCORES_STORAGE_KEY);
            if (storedScores) {
                highScores = JSON.parse(storedScores);
            } else {
                highScores = [];
            }
        }

        /**
         * Saves high scores to local storage. (Function kept for potential future use, not currently displayed)
         */
        function saveHighScores() {
            localStorage.setItem(HIGH_SCORES_STORAGE_KEY, JSON.stringify(highScores));
        }

        /**
         * Adds a new score to the high scores list. (Function kept for potential future use, not currently displayed)
         * @param {string} name - Player's name.
         * @param {number} score - Player's score.
         */
        function addHighScore(name, score) {
            highScores.push({ name: name, score: score });
            highScores.sort((a, b) => b.score - a.score); // Sort descending
            highScores = highScores.slice(0, MAX_HIGH_SCORES); // Keep only top N
            saveHighScores();
        }

        /**
         * Calculates the target dynamicTileSize for a given level based on current canvas dimensions.
         * @param {number} level - The level for which to calculate the target tile size.
         * @returns {number} The calculated target tile size.
         */
        function calculateTargetTileSize(level) {
            const initialMaxTileSize = Math.floor(Math.min(gameCanvas.width / MAX_VISIBLE_TILES_LEVEL1, gameCanvas.height / MAX_VISIBLE_TILES_LEVEL1));
            const finalMinTileSize = Math.floor(Math.min(gameCanvas.width / MIN_VISIBLE_TILES_MAX_LEVEL, gameCanvas.height / MIN_VISIBLE_TILES_MAX_LEVEL));
            let calculated = initialMaxTileSize - ((Math.min(level, ZOOM_LEVELS_EFFECTIVE) - 1) * (initialMaxTileSize - finalMinTileSize) / (ZOOM_LEVELS_EFFECTIVE - 1));
            return Math.max(finalMinTileSize, Math.floor(calculated));
        }



        /**
         * Initializes the game for a new level or a new game.
         * @param {boolean} resetGameStats - Whether to reset all game statistics.
         * @param {boolean} showGameStartOverlay - Whether to show the "HARD DIVISION" overlay.
         */
        function initGame(resetGameStats = true, showGameStartOverlay = false) {
            console.log('=== initGame() called ===', { resetGameStats, showGameStartOverlay });
            const wasGameOver = gameOver; // Capture state before resetting gameOver
            gameOver = false;
            window.addEventListener('keydown', handleKeyDown);
            
            console.log('About to check currentLevel and reset stats...');
            // Ensure currentLevel has a valid value before using it
            if (resetGameStats || currentLevel === undefined || currentLevel === null) {
                currentLevel = 1; // Initialize currentLevel first
                console.log('Set currentLevel to:', currentLevel);
                // Check for world progression on new game
                if (resetGameStats) {
                    checkAndUnlockWorlds();
                }
            }
            
            console.log('About to setup world colors...');
            // Set up world-specific colors and theme
            setupWorldColors();
            
            // Set initial map dimensions based on current level
            // Restored to original progression: small start with gradual growth
            const BASE_MAP_DIMENSION = 7;
            console.log("DEBUG: Map size calculation - currentLevel:", currentLevel, "resetGameStats:", resetGameStats);
            
            // Ensure currentLevel is valid before calculation
            const safeCurrentLevel = (typeof currentLevel === 'number' && !isNaN(currentLevel)) ? currentLevel : 1;
            console.log("DEBUG: Using safeCurrentLevel:", safeCurrentLevel);
            
            dynamicMapWidth = BASE_MAP_DIMENSION + Math.floor((safeCurrentLevel - 1) * 0.3);
            dynamicMapHeight = BASE_MAP_DIMENSION + Math.floor((safeCurrentLevel - 1) * 0.3);
            console.log("DEBUG: Calculated map size:", dynamicMapWidth + "x" + dynamicMapHeight);
            
            const MAX_MAP_DIMENSION = 60;
            dynamicMapWidth = Math.min(dynamicMapWidth, MAX_MAP_DIMENSION);
            dynamicMapHeight = Math.min(dynamicMapHeight, MAX_MAP_DIMENSION);

            // Initialize visited tiles grid
            visitedTiles = Array(dynamicMapHeight).fill(null).map(() => Array(dynamicMapWidth).fill(false));
            
            // Initialize core game objects
            if (!player) {
                player = { 
                    x: 0, 
                    y: 0, 
                    health: 1, 
                    name: generateAgentName(), 
                    healthAnimScale: 1, 
                    healthAnimStartTime: 0, 
                    thrustAnimActive: false, 
                    thrustAnimStartTime: 0, 
                    thrustAnimDirectionX: 0, 
                    thrustAnimDirectionY: 0, 
                    thrustAnimMagnitude: 0, 
                    lowestHealthReached: PLAYER_VISUAL_HEALTH_THRESHOLD, 
                    wasLowHealth: false, 
                    thrustAnimDuration: 200 
                };
            }
            
            if (!stairs) {
                stairs = { x: 0, y: 0 };
            }
            
            if (!key) {
                key = { x: 0, y: 0, collected: false };
            }
            
            // Reset door animation state for new level
            doorAnimActive = false;
            doorAnimStartTime = 0;
            if (doorAnimTimeoutId) {
                clearTimeout(doorAnimTimeoutId);
                doorAnimTimeoutId = null;
            }
            
            // Reset level transition state
            levelTransitionActive = false;
            nextLevelData = null;
            
            // Reset door shake animation for new level
            doorShakeActive = false;
            doorShakeStartTime = 0;
            
            // Reset triangle flying animation for new level
            triangleFlyActive = false;
            triangleFlyStartTime = 0;
            
            // Reset teleport animation for new level
            teleportAnimActive = false;
            teleportAnimStartTime = 0;
            
            if (!enemies) {
                enemies = [];
            }
            
            if (resetGameStats) {
                player.x = 0; // Reset player position
                player.y = 0;
                // currentLevel already set above
                player.health = 1; // Set player health to 1 for new game/restart
                hitsDealt = 0;
                hitsTaken = 0;
                stepsTaken = 0;
                totalDamageDealt = 0;
                // Reset per-level score tracking variables
                totalScore = 0; // Only reset totalScore on a true new game
                enemiesSpawnedThisLevel = 0;
                levelStartSteps = 0;
                levelStartDamage = 0;
                levelStartHitsTaken = 0;
                lastLevelScoreBreakdown = null;
                autoMode = null;
                // Reset death animation states
                deathAnimationActive = false;
                deathAnimationStartTime = 0;
                timeScale = 1;
                gameStartedOverlayActive = showGameStartOverlay; // This controls the fading overlay
                if (showGameStartOverlay) {
                    gameStartedOverlayStartTime = performance.now();
                }

                // IMPORTANT: Do NOT reset restartTextAnimationActive or restartTextParticles here
                // if we are coming from a game over state, as the animation needs to play out.
                // The drawGame loop will clear them once the animation duration is over.
                if (!wasGameOver) { // Only clear if it's a fresh start, not a restart from game over
                    restartTextAnimationActive = false;
                    restartTextParticles = [];
                }

                // Reset event tracking flags and history for a new game
                for (const key in eventFlags) {
                    eventFlags[key] = false;
                }
                player.lowestHealthReached = PLAYER_VISUAL_HEALTH_THRESHOLD;
                player.wasLowHealth = false;

                // Reset activity log for new game
                activityLog = [];

            } else {
                // Track damage at the start of this level for per-level scoring
                levelStartDamage = totalDamageDealt;
                // Heal player by current level number when advancing to a new level
                player.health = player.health + currentLevel; // Explicit assignment
                player.healthAnimScale = 1.5; // Trigger health animation
                player.healthAnimStartTime = performance.now();
                gameStartedOverlayActive = false; // Ensure it's off for level progression
                stepsTaken = 0; // Reset steps for new level
            }
            player.healthAnimScale = 1;
            player.healthAnimStartTime = 0;
            activeDamageTextAnimations = [];
            activeExplosions = [];
            activePickupAnimations = []; // Reset pickup animations for new level
            staticDamageNumbers = []; // Clear all static pickups for new level/game
            activeEventMessages = []; // Clear active event messages

            // Reset per-turn stats
            enemiesKilledThisTurn = 0;
            killedEnemiesThisTurn = []; // Reset killed enemies tracking
            damageDealtThisTurn = 0;
            hitsTakenThisTurn = 0;
            totalPickupValueCollectedThisTurn = 0;
            combatOccurredThisTurn = false; // Reset for new level
            playerTookDamageInCombatThisTurn = false; // Reset for new level

            const targetDynamicTileSizeForLevel = calculateTargetTileSize(currentLevel);

            if (resetGameStats) {
                // For a new game/restart, start zoomed in
                // Increase GAME_START_INITIAL_ZOOM_FACTOR for more zoom
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel * GAME_START_INITIAL_ZOOM_FACTOR);
                gameStartZoomActive = true;
                gameStartZoomStartTime = performance.now();
            } else {
                // For level progression, just set to the target size immediately
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel);
                gameStartZoomActive = false; // Ensure it's off for level progression
            }

            // Initialize visitedTiles grid
            visitedTiles = Array(dynamicMapHeight).fill(0).map(() => Array(dynamicMapWidth).fill(false));


            console.log(`Initializing Level ${currentLevel}. Map dimensions: ${dynamicMapWidth}x${dynamicMapHeight}`);

            let attempts = 0;
            const MAX_ATTEMPTS = 1000; // Max attempts to generate a connected map
            let mapGeneratedSuccessfully = false;

            // Map generation always happens now, as the game starts directly
            do {
                console.log(`Level ${currentLevel} - World ${currentWorld} (${getCurrentWorld().name}) - Map generation attempt: ${attempts + 1}`);
                initializeMap();
                generateWorldMap();

                // Validate map has floor tiles
                let floorTilesFound = false;
                for (let y = 0; y < dynamicMapHeight; y++) {
                    for (let x = 0; x < dynamicMapWidth; x++) {
                        if (gameMap[y][x] === TILE_FLOOR) {
                            floorTilesFound = true;
                            break;
                        }
                    }
                    if (floorTilesFound) break;
                }
                
                if (!floorTilesFound) {
                    console.error("No floor tiles generated - retrying map generation");
                    continue;
                }

                // Place player
                findPlayerStartInCorner(); // This function now ensures player is on a floor tile
                
                // Validate player position
                if (player.x === undefined || player.y === undefined || 
                    player.x === null || player.y === null ||
                    !gameMap[player.y] || gameMap[player.y][player.x] !== TILE_FLOOR) {
                    console.error("Invalid player placement - retrying map generation");
                    continue;
                }

                // Mark player's starting tile as visited
                if (visitedTiles[player.y] && visitedTiles[player.y][player.x] !== undefined) {
                    visitedTiles[player.y][player.x] = true;
                }
                console.log(`Player placed at (${player.x}, ${player.y})`);

                // Place stairs
                placeStairsOppositeCorner(); // This function now ensures stairs are on a stairs tile
                console.log(`Stairs placed at (${stairs.x}, ${stairs.y})`);

                // Place key
                placeKey();

                // Calculate player's average flow for new enemies
                const playerAverageFlowForNewEnemies = stepsTaken > 0 ? totalDamageDealt / stepsTaken : 0;

                // Spawn enemies
                // For level 1, pass 0 as levelHealthBonus to ensure enemy starts with 1 health
                // For other levels, pass player.health as before
                spawnEnemies(currentLevel === 1 ? 0 : player.health, playerAverageFlowForNewEnemies);

                // Spawn pickups for the current level
                spawnPickups();

                // Check path from player to stairs (enemies are now pre-validated to not create chokepoints)
                if (player.x !== undefined && player.y !== undefined && stairs.x !== undefined && stairs.y !== undefined) {
                    mapGeneratedSuccessfully = findPathBasic(player.x, player.y, stairs.x, stairs.y, gameMap, dynamicMapWidth, dynamicMapHeight, enemies) !== null;
                    console.log(`Path from player to stairs exists: ${mapGeneratedSuccessfully}`);
                } else {
                    mapGeneratedSuccessfully = false; // Cannot check path if player/stairs not valid
                    console.warn("Player or stairs not valid, map generation considered unsuccessful.");
                }

                attempts = attempts + 1; // Explicit assignment
                if (!mapGeneratedSuccessfully && attempts >= MAX_ATTEMPTS) {
                    console.warn(`Max map generation attempts (${MAX_ATTEMPTS}) reached for Level ${currentLevel}. Attempting to force a path.`);
                    // Force a path by creating a direct line of floor tiles from player to stairs
                    let currentPathX = player.x;
                    let currentPathY = player.y;
                    let pathSteps = 0;
                    const MAX_PATH_FORCING_STEPS = dynamicMapWidth * dynamicMapHeight * 2; // Safeguard

                    while ((currentPathX !== stairs.x || currentPathY !== stairs.y) && pathSteps < MAX_PATH_FORCING_STEPS) {
                        // Ensure current position is floor
                        if (gameMap[currentPathY] && gameMap[currentPathY][currentPathX] !== undefined) {
                            gameMap[currentPathY][currentPathX] = TILE_FLOOR;
                        }

                        const dx = stairs.x - currentPathX;
                        const dy = stairs.y - currentPathY;

                        if (dx !== 0 && dy !== 0) { // If both X and Y need to change
                            if (Math.abs(dx) > Math.abs(dy)) {
                                currentPathX = currentPathX + Math.sign(dx); // Explicit assignment
                            } else {
                                currentPathY = currentPathY + Math.sign(dy); // Explicit assignment
                            }
                        } else if (dx !== 0) { // Only X needs to change
                            currentPathX = currentPathX + Math.sign(dx); // Explicit assignment
                        } else if (dy !== 0) { // Only Y needs to change
                            currentPathY = currentPathY + Math.sign(dy); // Explicit assignment
                        }

                        // Ensure bounds for forced path
                        currentPathX = Math.max(0, Math.min(dynamicMapWidth - 1, currentPathX));
                        currentPathY = Math.max(0, Math.min(dynamicMapHeight - 1, currentPathY));

                        // Ensure the new step is floor, unless it's the stairs
                        if (currentPathX === stairs.x && currentPathY === stairs.y) {
                             gameMap[currentPathY][currentPathX] = TILE_STAIRS;
                        } else if (gameMap[currentPathY] && gameMap[currentPathY][currentPathX] !== undefined) {
                             gameMap[currentPathY][currentPathX] = TILE_FLOOR;
                        }
                        pathSteps = pathSteps + 1; // Explicit assignment
                    }
                    if (pathSteps >= MAX_PATH_FORCING_STEPS) {
                        console.error("Forced path generation hit max steps, likely stuck in an infinite loop logic. This should not happen with the new logic.");
                        // Fallback: Ensure stairs is at least TILE_STAIRS if loop exited prematurely
                        if (gameMap[stairs.y] && gameMap[stairs.y][stairs.x] !== undefined) {
                            gameMap[stairs.y][stairs.x] = TILE_STAIRS;
                        }
                    } else {
                        gameMap[stairs.y][stairs.x] = TILE_STAIRS; // Ensure stairs are still stairs at the end
                    }
                    mapGeneratedSuccessfully = true; // Path is now guaranteed
                    console.log("Forced a path from player to stairs.");
                }
            } while (!mapGeneratedSuccessfully);

            setupColors();
            // Animation loop is already started, no need to call startAnimationLoop() here.
            // It's continuously drawing the game.

            // If an auto-mode was active before initGame, restart it for the new level
            if (autoMode !== null) {
                startAutomatedMovement();
            }
            
            console.log("DEBUG: initGame() completed - Player health:", player.health, "Level:", currentLevel, "Position:", player.x, player.y);
        }

        // Handle canvas resizing for responsiveness
        function resizeCanvas() {
            // Get container dimensions
            const gameContainer = document.getElementById('gameContainer');
            const canvas = document.getElementById('gameCanvas');
            
            if (!gameContainer || !canvas) {
                console.error('Required elements not found:', { 
                    gameContainer: !!gameContainer, 
                    canvas: !!canvas 
                });
                return;
            }

            // Make canvas truly fullscreen
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;
            
            // Set the container dimensions to fullscreen
            gameContainer.style.width = `${canvasWidth}px`;
            gameContainer.style.height = `${canvasHeight}px`;
            
            // Set the canvas dimensions to fullscreen
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Calculate new tile size
            const targetDynamicTileSizeForLevel = calculateTargetTileSize(currentLevel);

            // Update the tile size
            if (gameStartZoomActive) {
                // Let the zoom animation handle the tile size
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel * GAME_START_INITIAL_ZOOM_FACTOR);
            } else {
                // Set tile size directly
                dynamicTileSize = Math.floor(targetDynamicTileSizeForLevel);
            }

            // Force a redraw
            drawGame();
        }

        // Wait for the DOM to be fully loaded before initializing
        console.log("=== SETTING UP DOM CONTENT LOADED LISTENER ===");
        document.addEventListener('DOMContentLoaded', function() {
            try {
                console.log('🚀 DOM Content Loaded - Initializing game...');
                console.log('🔍 Document ready state:', document.readyState);
                
                // Get canvas element and context
                gameCanvas = document.getElementById('gameCanvas');
                if (!gameCanvas) {
                    console.error('❌ Canvas element not found!');
                    document.body.innerHTML = '<h1 style="color: red;">ERROR: Canvas element not found</h1>';
                    return;
                }
                console.log('✅ Canvas element found:', gameCanvas);
            
            ctx = gameCanvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context!');
                return;
            }
            
            // Disable image smoothing for crisp pixel-art aesthetic with VT323 font
            ctx.imageSmoothingEnabled = false;
            
            console.log('Canvas and context successfully obtained');
            
            // Load total player score for world progression
            const savedScore = localStorage.getItem('hardDivisionTotalScore');
            if (savedScore) {
                totalPlayerScore = parseInt(savedScore);
            }
            checkAndUnlockWorlds();
            
            // Set initial background color based on current world
            updateBackgroundColor();
            
            console.log('About to initialize game...');
            console.log('Canvas element found:', gameCanvas ? 'YES' : 'NO');
            console.log('Context obtained:', ctx ? 'YES' : 'NO');
            
            // Initialize the game
            console.log('Calling initGame...');
            try {
                initGame(true, true); // Reset game stats and show overlay
                console.log('✅ initGame completed successfully');
            } catch (error) {
                console.error('❌ initGame failed:', error);
                document.body.innerHTML = '<h1 style="color: red; text-align: center; margin-top: 100px;">GAME INIT FAILED: ' + error.message + '</h1>';
                return;
            }
            
            // Set up event listeners
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize gamepad support
            startGamepadPolling();
            detectGamepad();
            
            // Initial canvas resize
            resizeCanvas();
            
            // Start the animation loop
            try {
                startAnimationLoop();
                console.log('✅ Animation loop started successfully');
            } catch (error) {
                console.error('❌ Animation loop failed:', error);
            }
            
            console.log('Game initialization complete');
        } catch (error) {
            console.error('❌ FATAL ERROR during game initialization:', error);
            document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 100px;"><h1>GAME INITIALIZATION FAILED</h1><p>' + error.message + '</p><pre>' + error.stack + '</pre></div>';
        }
});
    </script>
</body>
</html>
